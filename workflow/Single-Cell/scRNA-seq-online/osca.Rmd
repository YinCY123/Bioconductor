---
title: "Orchestrating Single-Cell Analysis with Bioconductor"
author: "yincy"
date: "2/28/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
```

# Chapter 1 Introduction  
```{r}
library(SingleCellExperiment)
```

### Workflows  
All workflows begin with data import and subsequent *quality control and normalization*, going from a raw (count) expression matrix to a clean one. This includes adjusting for experimental factors and possibly even latent factors. Using the clean expression matrix, *feature selection* strategies can be applied to select the features (genes) driving heterogeneity. Furthermore, these features can then be used to perform *dimensionality reduction*, which enables downstream analysis that would not otherwise be possible and visualization in 2 or 3 dimensions.  

From there, the workflows largely focus on differing downstream analyses. *Clustering* details how to segment a scRNA-seq dataset, and *differential expression* provides a means to determine what drives the differences between different groups of cells. *Integrating datasets* walks through merging scRNA-seq datasets, an area of need as the number of scRNA-seq datasets continues to grow and comparisons between datasets must be done. Finally, we touch upon how to work with *large scale data*, specifically where it becomes impractical or impossible to work with data solely in-memory.  


# Chapter 2 Learning R and Bioconductor  
- Codecademy [Learn R Series](https://www.codecademy.com/learn/learn-r)
- [R for Data Science](https://r4ds.had.co.nz/)book.  
- [tidyverse](https://www.tidyverse.org/) ecosystem  
- [Bioconductor Courses](https://bioconductor.org/help/course-materials/)  


# Chapter 3 Beyond R Basics  
## Becoming an R Expert  
- [Advanced R](https://adv-r.hadley.nz/)  
- [programming with S4](https://adv-r.hadley.nz/s4.html)  
- [R packages](http://r-pkgs.had.co.nz/)  
- [What They Forgot to Teach You About R](https://whattheyforgot.org/)  
- [R Inferno](https://www.burns-stat.com/pages/Tutor/R_inferno.pdf)  


## Nice Companions for R  
While not essential for our purposes, many bioinformatic tools for processing raw sequencing data require knowledge beyond just R to install, run, and import their results into R for further analysis. The most important of which are basic knowledge of the Shell/Bash utilities, for working with bioinformatic pipelines and troubleshooting (R package) installation issues.  

Additionally, for working with packages or software that are still in development and not hosted on an official repository like CRAN or Bioconductor, knowledge of Git - a version control system - and the popular GitHub hosting service is helpful. This enables you to not only work with other people’s code, but also better manage your own code to keep track of changes.  


### Shell/Bash  
[Shell/Bash](https://www.datacamp.com/courses/tech:shell)  

### Git
[Git](https://www.datacamp.com/courses/tech:git)  

### Other Languages  
- Python  
- C++ (Rcpp)  

# Chapter 4 Data Infrastructure  
## Background  
One of the main strengths of the Bioconductor project lies in the use of a common data infrastructure that powers interoperability across packages. Users should be able to analyze their data using functions from different Bioconductor packages without the need to convert between formats.  

```{r, fig.align='center', fig.cap='Overview of the structure of the 'SingleCellExperiment' class. Each row of the assyas corresponds to a row of the 'rowData'(pink shading), while each column of the assyas corresponds to a column of the 'colData' and 'reducedDims'(yellow shading).'}
knitr::include_graphics("figures/SingleCellExperiment.png")
```

Each piece of (meta)data in the `SingeCellExperiment` is represented by a separate 'slot'. (This terminology comes from the [S4 class system](https://adv-r.hadley.nz/s4.html)).  

## Storing primary experimental data  
### Filling the `assays` slot  
To construct a rudimentary `SingleCellExperiment` object, we only need to fill the `assays` slot. This contains primary data such as a matrix of sequencing counts where rows correspond to features (genes) and columns correspond to samples (cells).  

```{r}
counts_matrix <- data.frame(
    cell_1 = rpois(10, 10), 
    cell_2 = rpois(10, 10), 
    cell_3 = rpois(10, 30)
)

rownames(counts_matrix) <- paste("gene_", 1:10, sep = "")

counts_matrix <- as.matrix(counts_matrix) # must be a matrix object
```

```{r}
sce <- SingleCellExperiment(assays = list(counts = counts_matrix))
```

```{r}
sce
```

To access the count data  

- `assay(sce, "counts")`  
- `counts(sce)`  

```{r}
counts(sce)
```

```{r}
assays(sce, "counts")[[1]]
```

### Adding more `assays`  
What makes the `assays` slot especially powerful is that it can hold multiple representations of the primary data. This is especially useful for storing the raw count matrix as well as a normalized version of the data. We can do just that as shown below, using the `scater` package to compute a normalized and log-transformed representation of the initial primary data.  

```{r}
sce <- scater::logNormCounts(x = sce)
sce
```

```{r}
logcounts(sce)
```

```{r}
assays(sce)
```

```{r}
counts_100 <- counts(sce) + 100
assay(sce, "counts_100") <- counts_100 # assign a new entry to assays slot
assays(sce)
```


## Handling metadata  
### On the columns  
To further annotate our `SingleCellExperiment` object, we can add metadata to describe the columns of our primary data, e.g., the samples or cells of our experiment. This data is entered into the `colData` slot, a `data.frame` or `DataFrame` object where rows correspond to cells and columns correspond to metadata fields, e.g., batch of origin, treatment condition.  

```{r}
cell_metadata <- data.frame(batch = c(1, 1, 2))
rownames(cell_metadata) <- paste("cell_", 1:3, sep = "")
```

```{r}
sce <- SingleCellExperiment(assays = list(counts = counts_matrix), 
                            colData = cell_metadata)
sce
```

Access the column data with `colData()`  

```{r}
colData(sce)
```

Access the column data with `$`  

```{r}
sce$batch
```

Some functions automatically add column metadata by returning a `SingleCellExperiment` with extra fields in the `colData` slot. For example, the `scater` package contains the `addPerCellQC()` function that appends a lot of quality control data.  

```{r}
sce <- scater::addPerCellQC(x = sce)
colData(sce)
```

manually add more fields to the column metadata  

```{r}
sce$more_stuff <- runif(ncol(sce))
colnames(colData(sce))
```

A common operation with colData is to use its values for subsetting.  

```{r}
sce[, sce$batch == 1]
```

### On the rows  
To store feature-level annotation, the `SingleCellExperiment` has the `rowData` slot containing a `DataFrame` where each row corresponds to a gene and contains annotations like the transcript length or gene symbol. Furthermore, there is a special `rowRanges` slot to hold genomic coordinates in the form of a `GRanges` or `GRangesList`. This stores describes the chromosome, start, and end coordinates of the features (genes, genomic regions) in a manner that is easy to query and manipulate via the `GenomicRanges` framework.  

Both of the slots can be accessed via their respective accessors, `rowRanges()` and `rowData()`.  

```{r}
rowRanges(sce) # empty
```

```{r}
sce <- scater::addPerFeatureQC(sce)
rowData(sce)
```

The feature data could be provided at the onset when creating the `SingleCellExperiment` object.  

```{r}
library(EnsDb.Hsapiens.v86)
edb <- genes(EnsDb.Hsapiens.v86)

edb[, 2]
```

To subset a `SingleCellExperiment` object at the feature/gene level, we can do a row subsetting operation similar to other R objects, by supplying either **numeric indices or a vector of names**.  

```{r}
sce[c("gene_1", "gene_4"), ]
```

```{r}
sce[c(1, 4), ]
```


### Other metadata  
Some analyses contain results or annotations that do not fit into the aforementioned slots, e.g., study metadata. Thankfully, there is a slot just for this type of messy data - the `metadata` slot, a named list of entries where each entry in the list can be anything you want it to be.  

```{r}
my_genes <- c("gene_1", "gene_5")
metadata(sce) <- list(favorite_genes = my_genes)
metadata(sce)
```

append more information via `$`  
```{r}
your_genes <- c("gene_4", "gene_8")
metadata(sce)$your_genes <- your_genes

metadata(sce)
```


## Single-cell Specific fields  
### Background  
So far, we have covered the `assays` (primary data), `colData` (cell metadata), `rowData`/`rowRanges` (feature metadata), and `metadata` slots (other) of the `SingleCellExperiment` class. These slots are actually inherited from the `SummarizedExperiment` parent class (see here for details), so any method that works on a `SummarizedExperiment` will also work on a `SingleCellExperiment` object.  

### Dimensionality reduction results  
The `reducedDims` slot is specifically designed to store reduced dimensionality representations of the primary data obtained by methods such as PCA and t-SNE. This slot contains a list of numeric matrices of low-reduced representations of the primary data, where the rows represent the columns of the primary data, and columns represent the dimentions. As this slot holds a list, we can store multiple PCA/t-SNE/etc. results for the same dataset.  

```{r}
sce <- scater::logNormCounts(sce)
sce <- scater::runPCA(sce)
reducedDim(sce, "PCA")
```

```{r}
sce <- scater::runTSNE(sce, perplexity = 0.1)
reducedDim(sce, "TSNE")
```

```{r}
reducedDims(sce)
```

manually add content to the `reducedDims()` slot.  

```{r}
u <- uwot::umap(t(logcounts(sce)), n_neighbors = 2)

reducedDim(sce, "UMAP_uwot") <- u
reducedDims(sce)
```

```{r}
reducedDim(sce, "UMAP_uwot")
```

### Alternative Experiments  
The `SingleCellExperiment` class provides the concept of “alternative Experiments” where we have data for a distinct set of features but the same set of samples/cells. The classic application would be to store the per-cell counts for spike-in transcripts; this allows us to retain this data for downstream use but separate it from the `assays` holding the counts for endogenous genes. The separation is particularly important as such alternative features often need to be processed separately.  

If we have data for alternative feature sets, we can store it in our SingleCellExperiment as an alternative Experiment.  

```{r}
spike_counts <- cbind(cell_1 = rpois(5, 10), 
                      cell_2 = rpois(5, 10), 
                      cell_3 = rpois(5, 30))

rownames(spike_counts) <- paste("spike_", 1:5)
spike_se <- SummarizedExperiment(assays = list(counts = spike_counts))
spike_se
```

Then store this `SummarizedExperiment` in our `sce` object via the `altExp()` setter.  

```{r}
altExp(sce, "spike") <- spike_se
altExp(sce)
```

The alternative Experiment concept ensures that all relevant aspects of a single-cell dataset can be held in a single object. It is also convenient as it ensures that our spike-in data is synchronized with the data for the endogenous genes. For example, if we subsetted `sce`, the spike-in data would be subsetted to match.  

```{r}
sub <- sce[, 1:2]
altExp(sub, "spike")
```

Any `SummarizedExperiment` object can be stored as an alternative Experiment, including another `SingleCellExperiment`! This allows power users to perform tricks.   

### Size factors  
The `sizeFactors()` function allows us to get or set a numeric vector of per-cell scaling factors used for normalization. This is typically automatically added by normalization functions.  

```{r}
sce <- scran::computeSumFactors(sce)
sizeFactors(sce)
```

manually add the size factors  

```{r}
sizeFactors(sce) <- scater::librarySizeFactors(sce)
sizeFactors(sce)
```

Technically speaking, the `sizeFactors` concept is not unique to single-cell analyses. Nonetheless, we mention it here as it is an extension beyond what is available in the `SummarizedExperiment` parent class.  


### Column labels  
The `colLabels()` function allows us to get or set a vector or factor of per-cell labels, typically corresponding to groupings assigned by unsupervised clustering (see Chapter 10) or predicted cell type identities from classification algorithms.  

```{r no-this-function, eval=FALSE}
colLabels <- LETTERS[1:3]
colLabels(sce)
```


## Conclusion  
The widespread use of the `SingleCellExperiment` class provides the foundation for interoperability between single-cell-related packages in the Bioconductor ecosystem. `SingleCellExperiment` objects generated by one package can be used as input into another package, encouraging synergies that enable our analysis to be greater than the sum of its parts. Each step of the analysis will also add new entries to the `assays`, `colData`, `reducedDims`, etc., meaning that the final `SingleCellExperiment` object effectively serves as a self-contained record of the analysis. This is convenient as the object can be saved for future use or transferred to collaborators for further analysis.  


# Chapter 5 Overview  
## Introduction  
This chapter provides an overview of the framework of a typical scRNA-seq analysis workflow. Subsequent chapters will describe each analysis in more detail.  

```{r, fig.cap='Schenatic of a typical scRNA-seq analysis workflow. Each stage (separated by dashed lines) consists of a number of specific steps, many of which operate on and modify a `SingleCellExperiment` instance.'}
knitr::include_graphics("figures/scRNA-seq-analysis-workflow.png")
```


## Experimental Design  
Before starting the analysis itself, some comments on experimental design may be helpful. The most obvious question is the choice of technology, which can be roughly divided into:  
- Droplet-based: 10X Genomics, inDrop, Drop-seq  
- Plate-based with unique molecular identifiers (UMIs): CEL-seq, MARS-seq  
- Plate-based with reads: Smart-seq2  
- Other: sci-RNA-seq, Seq-Well  

Papers describe the advantages and weaknesses
- PMID: 32518403  
- PMID: 28212749  

In practical terms, <a style='color="red"'>droplet-based technologies are the current de facto standard due to their throughput and low cost per cell. Plate-based methods can capture other phenotypic information (e.g., morphology) and are more amenable to customization. Read-based methods provide whole-transcript coverage, which is useful in some applications (e.g., splicing, exome mutations); otherwise, UMI-based methods are more popular as they mitigate the effects of PCR amplification noise</a>.  

The next question is how many cells should be captured, and to what depth they should be sequenced. The short answer is “as much as you can afford to spend”. The long answer is that it depends on the aim of the analysis. If we are aiming to discover rare cell subpopulations, then we need more cells. If we are aiming to characterize subtle differences, then we need more sequencing depth. As of time of writing, an informal survey of the literature suggests that typical droplet-based experiments would capture anywhere from 10,000 to 100,000 cells, sequenced at anywhere from 1,000 to 10,000 UMIs per cell (usually in inverse proportion to the number of cells). Droplet-based methods also have a trade-off between throughput and doublet rate that affects the true efficiency of sequencing.  

For studies involving multiple samples or conditions, the design considerations are the same as those for bulk RNA-seq experiments. There should be multiple biological replicates for each condition and conditions should not be confounded with batch. Note that individual cells are not replicates; rather, we are referring to samples derived from replicate donors or cultures.  

## Obtaining a count matrix  
Sequencing data from scRNA-seq experiments must be converted into a matrix of expression values that can be used for statistical analysis. Given the discrete nature of sequencing data, this is usually a count matrix containing the number of UMIs or reads mapped to each gene in each cell. The exact procedure for quantifying expression tends to be technology-dependent:  

- For 10X Genomics data, the `CellRanger` software suite provides a custom pipeline to obtain a count matrix. This uses STAR to align reads to the reference genome and then counts the number of unique UMIs mapped to each gene.  

- Pseudo-alignment methods such as `alevin` can be used to obtain a count matrix from the same data with greater efficiency. This avoids the need for explicit alignment, which reduces the compute time and memory usage.  

- For other highly mutiplexed protocols, the `scPipe` package provides a more general pipeline for processing scRNA-seq data. This uses the `Rsubread` aligner to align reads and then counts UMIs per gene.  

- For CEL-seq or CEL-seq2 data, the `scruff` package provides a dedicated pipline for quantification.  

- For read-based protocols, we can generally re-use the same pipelines for processing bulk RNA-seq data.  

- For any data involving spike-in transcripts, the spike-in sequences should be included as part of the reference genome during alignment and quantification.  

After quantification, we import the count matrix into R and create a `SingleCellExperiment` object. This can be done with base methods (e.g., `read.table()`) followed by applying the `SingleCellExperiment()` constructor. Alternatively, for specific file formats, we can use dedicated methods from the `DropletUtils` (for 10X data) or `tximport`/`tximeta` packages (for pseudo-alignment methods). Depending on the origin of the data, this requires some vigilance:  

- Some feature-counting tools will report mapping statistics in the count matrix (e.g., the number of unaligned or unassigned reads). While these values can be useful for quality control, they would be misleading if treated as gene expression values. Thus should be removed (or at least moved to the `colData`) prior to feature analyses.  

- Be careful of using the `^RECC` regular expression to detect spike-in rows in human data where the row names of the count matrix are gene symbols. An ERCC gene family actually exists in human annotation, so this would result in incorrect identification of genes as spike-in transcripts. This problem can be avoided by using count matrices with standard identifiers (e.g., Ensembl, Entrez).  

## Data Processing and downstream analysis  
In the simplest case, the workflow has the following form:  

1. **We compute quality control metrics to remove low-quality cells that would interfere with downstream analyses**. These cells may have been damaged during processing or may not have been fully captured by the sequencing protocol. Common metrics includes the total counts per cell, the proportion of spike-in or mitochondrial reads and the number of detected features.  

2. **We convert the counts into normalized expression values to elimiinate cell-specific biases** (e.g., in capture efficiency). This allows us to perform explicit comparisons across cells in downstream steps like clustering. **We also apply a transformation, typically log, to adjust for the mean-variance relationship**.  

3. **We perform feature selection to pick a subset of interesting features for downstream analysis**. This is done by modelling the variance across cells for each gene and retaining genes that are highly variable. The aim is to reduce computational overhead and noise from uninteresting genes.   

4. **We apply dimensionality reduction to compact the data and further reduce noise**. Principal components analysis is typically used to obtain an initial low-rank representation for more computational work, followed by more aggressive methods like t-stochastic neighbor embedding for visualization purposes.  

5. **We cluster cells into groups according to similarities in their (normalized) expression profiles**. This aims to obtain groupings that serve as empirical proxies for distinct biological states. We typically interpret these groupings by identifying differentially expressed marker genes between clusters.  


## Quick start  
Here, we use the a droplet-based retina dataset from Macosko et al.([2015](http://dx.doi.org/10.1016/j.cell.2015.05.002)), provided in the scRNAseq package. This starts from a count matrix and finishes with clusters in preparation for biological interpretation. Similar workflows are available in abbreviated from the Workflows.  

```{r}
library(scRNAseq)
sce <- MacoskoRetinaData()

# Quality control
library(scater)
is.mito <- grepl("^MT-", rownames(sce))
qcstats <- perCellQCMetrics(sce, subsets = list(Mito = is.mito))
filtered <- quickPerCellQC(df = qcstats, percent_subsets = "subsets_Mito_percent")
sce <- sce[, !filtered$discard]

# Normalization  
sce <- logNormCounts(sce)

# feature selection  
library(scran)
dec <- modelGeneVar(sce)
hvg <- getTopHVGs(dec, prop = 0.1)

# dimensionality reduction
set.seed(1234)
sce <- runPCA(sce, ncomponents = 25, subset_row = hvg)
sce <- runUMAP(sce, dimred = "PCA", external_neighbors = TRUE)


# clustering
g <- buildSNNGraph(sce, use.dimred = "PCA")
colLabels(sce) <- factor(igraph::cluster_louvain(g)$membership)

# visualization
plotUMAP(sce, colour_by = "label")
```


# Chapter 6 Quality Control  
Low-quality libraries in scRNA-seq data can arise from a variety of sources such as cell damage during dissociation or failure in library preparation (e.g., inefficient reverse transcription or PCR amplification). **These usually manifest as “cells” with low total counts, few expressed genes and high mitochondrial or spike-in proportions**. These low-quality libraries are problematic as they can contribute to misleading results in downstream analyses:  

- They form their own distinct cluster(s), complicating interpretation of the results. This is most obviously driven by increased mitochondrial proportions or enrichment for nuclear RNAs after cell damage. In the worst case, low-quality libraries generated from different cell types can cluster together based on similarities in the damage-induced expression profiles, creating artificial intermediate states or trajectories between otherwise distinct subpopulations. Additionally, very small libraries can form their own clusters due to shifts in the mean upon transformation.  

- They distort the characterization of population heterogeneity during variance estimation or principal components analysis. The first few principal components will capture differences in quality rather than biology, reducing the effectiveness of dimensionality reduction. Similarly, genes with the largest variances will be driven by differences between low- and high-quality cells. The most obvious example involves low-quality libraries with very low counts where scaling normalization inflates the apparent variance of genes that happen to have a non-zero count in those libraries.  

- They contain genes that appear to be strongly “upregulated” due to aggressive scaling to normalize for small library sizes. This is most problematic for contaminating transcripts (e.g., from the ambient solution) that are present in all libraries at low but constant levels. Increased scaling in low-quality libraries transforms small counts for these transcripts in large normalized expression values, resulting in apparent upregulation compared to other cells. This can be misleading as the affected genes are often biologically sensible but are actually expressed in another subpopulation.  

To avoid - or at least mitigate - these problems, we need to remove these cells at the start of the analysis. This step is commonly referred to as quality control (QC) on the cells.  

scRNA-seq dataset from [PMID:29030468]
```{r}
library(scRNAseq)

load("data/sce.416b.RData")
sce.416b$block <- factor(sce.416b$block)
```


## Choice of QC metrics  
We use several common QC metrics to identify low-quality cells based on their expression profiles. These metrics are described below in terms of reads for SMART-seq2 data, but the same definitions apply to UMI data generated by other technologies like MARS-seq and droplet-based protocols.  

- The library size is defined as the total sum of counts across all relevant features for each cell. Here, we will consider the relevant features to be the endogenous genes. Cells with small library sizes are of low quality as the RNA has been lost at some point during library preparation, either due to cell lysis or inefficient cDNA capture and amplification.  

- The number of expressed features in each cell is defined as the number of endogenous genes with non-zero counts for that cell. Any cell with very few expressed genes is likely to be of poor quality as the diverse transcript population has not been successfully captured.  

- The proportion of reads mapped to spike-in transcripts is calculated relative to the total count across all features (including spike-ins) for each cell. As the same amount of spike-in RNA should have been added to each cell, any enrichment in spike-in counts is symptomatic of loss of endogenous RNA. Thus, high proportions are indicative of poor-quality cells where endogenous RNA has been lost due to, e.g., partial cell lysis or RNA degradation during dissociation.  

- In the absence of spike-in transcripts, the proportion of reads mapped to genes in the mitochondrial genome can be used. High proportions are indicative of poor-quality cells (Islam et al. 2014; Ilicic et al. 2016), presumably because of loss of cytoplasmic RNA from perforated cells. The reasoning is that, in the presence of modest damage, the holes in the cell membrane permit efflux of individual transcript molecules but are too small to allow mitochondria to escape, leading to a relative enrichment of mitochondrial transcripts. For single-nuclei RNA-seq experiments, high proportions are also useful as they can mark cells where the cytoplasm has not been successfully stripped.  

For each cell, we calculate these QC metrics using the `perCellQCMetrics()` function from the `scater` package (McCarthy et al. 2017). The `sum` column contains the total count for each cell and the `detected` column contains the number of detected genes. The `subsets_Mito_percent` column contains the percentage of reads mapped to mitochondrial transcripts. (For demonstration purposes, we show two different approaches of determining the genomic location of each transcript.) Finally, the `altexps_ERCC_percent` column contains the percentage of reads mapped to ERCC transcripts.  

```{r}
library(AnnotationHub)
ens.mm.v97 <- AnnotationHub()[["AH73905"]]

# retrieving the mitochondrial transcripts using genomic locations included in the low-level annotation for the SingleCellExperiment.  
location <- rownames(sce.416b) %>% 
    select(ens.mm.v97, 
           keys = ., 
           keytype = "GENEID", 
           columns = c("GENEID", "SYMBOL"))

is.mito <- grepl("^MT-", location$SYMBOL, ignore.case = T)


# # ALTERNATIVELY: using resources in AnnotationHub to retrieve chromosomal locations given the Ensembl IDs; this should yield the same result.  
# library(EnsDb.Mmusculus.v79)

# chr.loc <- select(EnsDb.Mmusculus.v79, 
#                   keys = rownames(sce.416b), 
#                   keytype = "GENEID", 
#                   column = c("SYMBOL", "GENEID"))
# chr.loc %>% head()
# 
# is.mito.alt <- grepl("^MT-", chr.loc$SYMBOL, ignore.case = T)
# is.mito.alt %>% table

library(scater)
df <- perCellQCMetrics(sce.416b, subset = list(Mito = is.mito))
```

Alternatively, users may prefer to use the addPerCellQC() function. This computes and appends the per-cell QC statistics to the colData of the SingleCellExperiment object, allowing us to retain all relevant information in a single object for later manipulation.  

```{r}
sce.416b <- addPerCellQC(x = sce.416b, subsets = list(Mito = is.mito))
colData(sce.416b) %>% colnames()
```

**A key assumption here is that the QC metrics are independent of the biological state of each cell**. Poor values (e.g., low library sizes, high mitochondrial proportions) are presumed to be driven by technical factors rather than biological processes, meaning that the subsequent removal of cells will not misrepresent the biology in downstream analyses. Major violations of this assumption would potentially result in the loss of cell types that have, say, systematically low RNA content or high numbers of mitochondria.  


## Identifying low-quality cells  
### With fixed thresholds  
The simplest approach to identifying low-quality cells is to apply thresholds on the QC metrics. For example, we might consider cells to be low quality if they have library sizes below 100,000 reads; express fewer than 5,000 genes; have spike-in proportions above 10%; or have mitochondrial proportions above 10%.  

```{r}
qc.lib <- df$sum < 1e5
qc.nexprs <- df$detected < 5e3
qc.spike <- df$altexps_ERCC_percent > 10
qc.mito <- df$subsets_Mito_percent > 0.1
discard <- qc.lib | qc.nexprs | qc.spike | qc.mito

# Summarize the number of cells removed for each reason
tibble(LibSize = sum(qc.lib), 
          NExpers = sum(qc.nexprs), 
          SpikeProp = sum(qc.spike), 
          MitoProp = sum(qc.mito), 
          Total = sum(discard))

# on the SingleCellExperiment object
# qc.sc.lib <- sce.416b$sum < 1e5
# qc.sc.nexpers <- sce.416b$detected < 5e3
# qc.sc.spike <- sce.416b$altexps_ERCC_percent > 10
# qc.sc.mito <- sce.416b$subsets_Mito_percent > 0.1
# discard <- qc.sc.lib | qc.sc.nexpers | qc.sc.spike | qc.sc.mito
# 
# sce.416b <- sce.416b[, discard]
```

While simple, this strategy requires considerable experience to determine appropriate thresholds for each experimental protocol and biological system. **Thresholds for read count-based data are simply not applicable for UMI-based data, and vice versa**. Differences in mitochondrial activity or total RNA content require constant adjustment of the mitochondrial and spike-in thresholds, respectively, for different biological systems. Indeed, even with the same protocol and system, the appropriate threshold can vary from run to run due to the vagaries of cDNA capture efficiency and sequencing depth per cell.  


### With adaptive thresholds  
#### Identifying outliers  
**To obtain an adaptive threshold, we assume that most of the dataset consists of high-quality cells. We then identify cells that are outliers for the various QC metrics, based on the median absolute deviation (MAD) from the median value of each metric across all cells**. Specifically, a value is considered an outlier if it is more than 3 MADs from the median in the “problematic” direction. This is loosely motivated by the fact that such a filter will retain 99% of non-outlier values that follow a normal distribution.  

For the 416B data, we identify cells with log-transformed library sizes that are more than 3 MADs below the median. A log-transformation is used to improve resolution at small values when type="lower". Specifically, it guarantees that the threshold is not a negative value, which would be meaningless for a non-negative metric. Furthermore, it is not uncommon for the distribution of library sizes to exhibit a heavy right tail; the log-transformation avoids inflation of the MAD in a manner that might compromise outlier detection on the left tail. (More generally, it makes the distribution seem more normal to justify the 99% rationale mentioned above.)  

```{r}
qc.lib2 <- isOutlier(metric = df$sum, log = T, type = "lower")
```

We do the same for the log-transformed number of expressed genes.  

```{r}
qc.nexpers2 <- isOutlier(df$detected, log = T, type = "lower")
```

`is.Outlier()` will also return the exact filter thresholds for each metric in the attributes of the output vector. These are useful for checking whether the automatically selected thresholds are appropriate.  

```{r}
attr(qc.lib2, "thresholds")
```

```{r}
attr(qc.nexpers2, "thresholds")
```

We identify outliers for the proportion-based metrics with the same function. These distributions frequently exhibit a heavy right tail, but unlike the two previous metrics, it is the right tail itself that contains the putative low-quality cells. Thus, we do not perform any transformation to shrink the tail - rather, our hope is that the cells in the tail are identified as large outliers. (While it is theoretically possible to obtain a meaningless threshold above 100%, this is rare enough to not be of practical concern.)  

```{r}
qc.spike2 <- isOutlier(df$altexps_ERCC_percent, type = "higher")
attr(qc.spike2, "thresholds")
```

```{r}
qc.mito2 <- isOutlier(df$subsets_Mito_percent, type = "higher")
attr(qc.mito2, "thresholds")
```

A cell that is an outlier for any of these metrics is considered to be of low quality and discarded.  

```{r}
discard2 <- qc.lib2 | qc.nexpers2 | qc.spike2 | qc.mito2

# Summarize the number of cells removed for each reason.  
library(tibble)

tibble(
    LibSize = sum(qc.lib2), 
    NExpes = sum(qc.nexpers2), 
    SpikeProp = sum(qc.spike2), 
    MitoProp = sum(qc.mito2), 
    Total = sum(discard2)
)
```

Alternatively, this entire process can be done in a single step using the `quickPerCellQC()` function. This is a wrapper that simply calls `isOutlier()` with the settings described above.  

```{r}
reasons <- quickPerCellQC(df, 
                          lib_size = "sum", 
                          n_features = "detected", 
                          percent_subsets = c("subsets_Mito_percent", 
                                              "altexps_ERCC_percent", 
                                              "altexps_SIRV_percent"))

reasons %>% as_tibble() %>% colnames()
```

With this strategy, the thresholds adapt to both the location and spread of the distribution of values for a given metric. This allows the QC procedure to adjust to changes in sequencing depth, cDNA capture efficiency, mitochondrial content, etc. without requiring any user intervention or prior experience. However, it does require some implicit assumptions that are discussed below in more detail.  

#### Assumptions of outlier detection  
Outlier detection assumes that most cells are of acceptable quality. This is usually reasonable and can be experimentally supported in some situations by visually checking that the cells are intact, e.g., on the microwell plate. If most cells are of (unacceptably) low quality, the adaptive thresholds will obviously fail as they cannot remove the majority of cells. Of course, what is acceptable or not is in the eye of the beholder - neurons, for example, are notoriously difficult to dissociate, and we would often retain cells in a neuronal scRNA-seq dataset with QC metrics that would be unacceptable in a more amenable system like embryonic stem cells.  

Another assumption mentioned earlier is that the QC metrics are independent of the biological state of each cell. This is most likely to be violated in highly heterogeneous cell populations where some cell types naturally have, e.g., less total RNA (see Figure 3A of Germain, Sonrel, and Robinson (2020)) or more mitochondria. Such cells are more likely to be considered outliers and removed, even in the absence of any technical problems with their capture or sequencing. The use of the MAD mitigates this problem to some extent by accounting for biological variability in the QC metrics. A heterogeneous population should have higher variability in the metrics among high-quality cells, increasing the MAD and reducing the chance of incorrectly removing particular cell types (at the cost of reducing power to remove low-quality cells).  

In general, these assumptions are either reasonable or their violations have little effect on downstream conclusions. Nonetheless, it is helpful to keep them in mind when interpreting the results.  

#### Considering experimental factors  
More complex studies may involve batches of cells generated with different experimental parameters (e.g., sequencing depth). In such cases, the adaptive strategy should be applied to each batch separately. It makes little sense to compute medians and MADs from a mixture distribution containing samples from multiple batches. For example, if the sequencing coverage is lower in one batch compared to the others, it will drag down the median and inflate the MAD. This will reduce the suitability of the adaptive threshold for the other batches.  

If each batch is represented by its own `SingleCellExperiment`, the `isOutlier()` function can be directly applied to each batch as shown above. However, if cells from all batches have been merged into a single `SingleCellExperiment`, the `batch=` argument should be used to ensure that outliers are identified within each batch. This allows `isOutlier()` to accommodate systematic differences in the QC metrics across batches.  

We will again illustrate using the 416B dataset, which contains two experimental factors - plate of origin and oncogene induction status. We combine these factors together and use this in the `batch=` argument to `isOutlier()` via `quickPerCellQC()`. This results in the removal of slightly more cells as the MAD is no longer inflated by (i) systematic differences in sequencing depth between batches and (ii) differences in number of genes expressed upon oncogene induction.  

```{r}
batch <- paste0(sce.416b$phenotype, "-", sce.416b$block)
batch %>% table

batch.reasons <- quickPerCellQC(df, 
                                batch = batch, 
                                percent_subsets = c("subsets_Mito_percent", 
                                                    "altexps_ERCC_percent"))

batch.reasons %>% as_tibble() %>% colSums()
```

That said, the use of `batch=` involves the stronger assumption that most cells in each batch are of high quality. If an entire batch failed, outlier detection will not be able to act as an appropriate QC filter for that batch. For example, two batches in the Grun et al. (2016) human pancreas dataset contain a substantial proportion of putative damaged cells with higher ERCC content than the other batches. This inflates the median and MAD within those batches, resulting in a failure to remove the assumed low-quality cells. In such cases, it is better to compute a shared median and MAD from the other batches and use those estimates to obtain an appropriate filter threshold for cells in the problematic batches, as shown below.  

```{r}
sce.grun <- GrunPancreasData()
sce.grun <- addPerCellQC(sce.grun)

# first attempt with batch-specific thresholds
discard.ercc <- isOutlier(sce.grun$altexps_ERCC_percent, 
                          type = "higher", 
                          batch = sce.grun$donor)

with.blocking <- plotColData(object = sce.grun, 
                             x = "donor", 
                             y = "altexps_ERCC_percent", 
                             colour_by = I(discard.ercc)) +
    ggtitle(label = "with blocking")


# second attemp, sharing information across batches to avoid dramatically different thresholds for unusual batches.  
discard.ercc2 <- isOutlier(sce.grun$altexps_ERCC_percent, 
                           type = "higher", 
                           batch = sce.grun$donor, 
                           subset = sce.grun$donor %in% c("D17", "D2", "D7"))

without.blocking <- plotColData(object = sce.grun, 
                                x = "donor", 
                                y = "altexps_ERCC_percent", 
                                colour_by = I(discard.ercc2)) +
    ggtitle(label = "without blocking")

cowplot::plot_grid(with.blocking, without.blocking)
```

To identify problematic batches, one useful rule of thumb is to find batches with QC thresholds that are themselves outliers compared to the thresholds of other batches. The assumption here is that most batches consist of a majority of high quality cells such that the threshold value should follow some unimodal distribution across “typical” batches. If we observe a batch with an extreme threshold value, we may suspect that it contains a large number of low-quality cells that inflate the per-batch MAD. We demonstrate this process below for the Grun et al. (2016) data.  

```{r}
ercc.thresholds <- attr(discard.ercc, "thresholds")["higher", ]
names(ercc.thresholds)[isOutlier(ercc.thresholds, type = "higher")]
```

If we cannot assume that most batches contain a majority of high-quality cells, then all bets are off; we must revert to the approach of picking an arbitrary threshold value (Section 6.3.1) and hoping for the best.  

### Other approaches  
Another strategy is to identify outliers in high-dimensional space based on the QC metrics for each cell. We use methods from `robustbase` to quantify the “outlyingness” of each cells based on their QC metrics, and then use `isOutlier()` to identify low-quality cells that exhibit unusually high levels of outlyingness.  

```{r}
stats <- cbind(log10(df$sum), log10(df$detected), 
               df$subsets_Mito_percent, 
               df$altexps_ERCC_percent)

library(robustbase)
outlying <- adjOutlyingness(x = stats, only.outlyingness = TRUE)
multi.outlier <- isOutlier(outlying, type = "higher")
summary(multi.outlier)
```

This and related approaches like PCA-based outlier detection and support vector machines can provide more power to distinguish low-quality cells from high-quality counterparts (Ilicic et al. 2016) as they can exploit patterns across many QC metrics. However, this comes at some cost to interpretability, as the reason for removing a given cell may not always be obvious.  

For completeness, we note that outliers can also be identified from the gene expression profiles, rather than QC metrics. We consider this to be a risky strategy as it can remove high-quality cells in rare populations.  

## Checking diagnostic plots  
It is good practice to inspect the distributions of QC metrics (Figure 6.2) to identify possible problems. In the most ideal case, we would see normal distributions that would justify the 3 MAD threshold used in outlier detection. A large proportion of cells in another mode suggests that the QC metrics might be correlated with some biological state, potentially leading to the loss of distinct cell types during filtering; or that there were inconsistencies with library preparation for a subset of cells, a not-uncommon phenomenon in plate-based protocols. Batches with systematically poor values for any metric can then be quickly identified for further troubleshooting or outright removal, much like in (Figure 6.1) above.  

```{r}
colData(sce.416b) <- cbind(colData(sce.416b), df)
sce.416b$block <- factor(sce.416b$block)
sce.416b$phenotype <- ifelse(grepl("induced", sce.416b$phenotype), "induced", "wild type")
sce.416b$discard <- reasons$discard

cowplot::plot_grid(plotlist = list(
    plotColData(sce.416b, x = "block", 
                y = "sum", 
                colour_by = "discard", 
                other_fields = "phenotype") +
        facet_wrap(~phenotype) +
        ggtitle("Total count"), 
    plotColData(sce.416b, x = "block", 
                y = "detected", 
                colour_by = "discard", 
                other_fields = "phenotype") +
        facet_wrap(~phenotype) +
        ggtitle("Detected features"), 
    plotColData(sce.416b, 
                x = "block", 
                y = "subsets_Mito_detected.1", 
                colour_by = "discard", 
                other_fields = "phenotype") +
        facet_wrap(~phenotype) +
        ggtitle("Mito percent"), 
    plotColData(sce.416b, 
                x = "block", 
                y = "altexps_ERCC_percent", 
                other_fields = "phenotype") +
        facet_wrap(~phenotype) +
        ggtitle("ERCC percent")
), 
ncol = 1)
```

Another useful diagnostic involves plotting the proportion of mitochondrial counts against some of the other QC metrics. The aim is to confirm that there are no cells with both large total counts and large mitochondrial counts, to ensure that we are not inadvertently removing high-quality cells that happen to be highly metabolically active (e.g., hepatocytes). We demonstrate using data from a larger experiment involving the mouse brain (Zeisel et al. 2015); in this case, we do not observe any points in the top-right corner in Figure 6.3 that might potentially correspond to metabolically active, undamaged cells.  

```{r}
# sce.zeisel <- ZeiselBrainData()
sce.zeisel <- readRDS("data/sce.zeisel.rds")

library(scater)
sce.zeisel <- aggregateAcrossFeatures(x = sce.zeisel, 
                                      ids = sub("_loc[0-9]+$", "", rownames(sce.zeisel)))

library(org.Mm.eg.db)
rowData(sce.zeisel)$Ensembl <- mapIds(org.Mm.eg.db, 
                                      keys = rownames(sce.zeisel), 
                                      keytype = "SYMBOL", 
                                      column = "ENSEMBL")

sce.zeisel <- addPerCellQC(sce.zeisel, 
                           subsets = list(Mt = rowData(sce.zeisel)$featureType == "mito"))

qc <- quickPerCellQC(colData(sce.zeisel), 
                     percent_subsets = c("altexps_ERCC_percent", "subsets_Mt_percent"))
sce.zeisel$discard <- qc$discard

plotColData(sce.zeisel, 
            x = "sum", 
            y = "subsets_Mt_percent", 
            colour_by = "discard")
```

Comparison of the ERCC and mitochondrial percentages can also be informative (Figure 6.4). Low-quality cells with small mitochondrial percentages, large spike-in percentages and small library sizes are likely to be stripped nuclei, i.e., they have been so extensively damaged that they have lost all cytoplasmic content. On the other hand, **cells with high mitochondrial percentages and low ERCC percentages may represent undamaged cells that are metabolically active**. This interpretation also applies for single-nuclei studies but with a switch of focus: the stripped nuclei become the libraries of interest while the undamaged cells are considered to be low quality.  

```{r}
plotColData(sce.zeisel, 
            x = "altexps_ERCC_percent", 
            y = "subsets_Mt_percent", 
            colour_by = "discard")
```

We see that all of these metrics exhibit weak correlations to each other, presumably a manifestation of a common underlying effect of cell damage. The weakness of the correlations motivates the use of several metrics to capture different aspects of technical quality. Of course, the flipside is that these metrics may also represent different aspects of biology, increasing the risk of discarding entire cell types.  

## Removing low-quality cells  
Once low-quality cells have been identified, we can choose to either remove them or mark them. Removal is the most straightforward option and is achieved by subsetting the `SingleCellExperiment` by column. In this case, we use the low-quality calls from Section 6.3.2.3 to generate a subsetted `SingleCellExperiment` that we would use for downstream analyses.  

```{r}
# keeping the columns we don't want to discard.  

filtered <- sce.416b[, !reasons$discard]
```

The biggest practical concern during QC is whether an entire cell type is inadvertently discarded. There is always some risk of this occurring as the QC metrics are never fully independent of biological state. We can diagnose cell type loss by looking for systematic differences in gene expression between the discarded and retained cells. To demonstrate, we compute the average count across the discarded and retained pools in the 416B data set, and we compute the log-fold change between the pool averages.

```{r}
# using the `discard` vector for demonstration purpose, as it has more cells for stable calculation of 'lost'.

lost <- calculateAverage(x = counts(sce.416b)[, !reasons$discard])
kept <- calculateAverage(x = counts(sce.416b)[, reasons$discard])

library(edgeR)
logged <- cpm(cbind(lost, kept), log = T, prior.count = 2)
logFC <- logged[, 1] - logged[, 2]
abundance <- rowMeans(logged)
```

If the discarded pool is enriched for a certain cell type, we should observe increased expression of the corresponding marker genes. No systematic upregulation of genes is apparent in the discarded pool, suggesting that the QC step did not inadvertently filter out a cell type in the 416B dataset.  

```{r, fig.cap='Log-fold change in expression in the discarded cells compared to the retained cells in the 416B dataset. Each point represents a gene with mitochondrial transcripts in blue.'}
plot(abundance, logFC, xlab = "Average count", ylab = "Log-FC(lost/kept)", pch = 16)
points(abundance[is.mito], logFC[is.mito], col = "dodgerblue", pch  =16)
```

For comparison, let us consider the QC step for the PBMC dataset from 10X Genomics (Zheng et al. 2017). We’ll apply an arbitrary fixed threshold on the library size to filter cells rather than using any outlier-based method. Specifically, we remove all libraries with a library size below 500.  

```{r}
library(DropletTestFiles)
raw.path <- getTestFile("tenx-2.1.0-pbmc4k/1.0.0/raw.tar.gz")
out.path <- file.path("/home/yincy/git/Bioconductor/workflow/Single-Cell/scRNA-seq-online/data/", "pbmc4k")
untar(raw.path, exdir = out.path)


library(DropletUtils)
library(scuttle)
fname <- file.path(out.path, "raw_gene_bc_matrices/GRCh38")
# sce.pbmc <- read10xCounts(fname, col.names = T)
sce.pbmc <- readRDS("data/sce.pbmc.rds")

# gene annotation 
library(scater)

rownames(sce.pbmc) <- uniquifyFeatureNames(rowData(sce.pbmc)$ID, 
                                           rowData(sce.pbmc)$Symbol)

library(EnsDb.Hsapiens.v86)
location <- mapIds(EnsDb.Hsapiens.v86, 
                   keys = rowData(sce.pbmc)$ID, 
                   keytype = "GENEID", 
                   column = "SEQNAME")

# cell detection
set.seed(100)
e.out <- emptyDrops(counts(sce.pbmc))
sce.pbmc <- sce.pbmc[, which(e.out$FDR <= 0.001)]
```

```{r}
discard <- colSums(counts(sce.pbmc)) < 500
lost <- calculateAverage(counts(sce.pbmc)[, discard])
kept <- calculateAverage(counts(sce.pbmc)[, !discard])

logged <- edgeR::cpm(cbind(lost, kept), log = T, prior.count = 2)
logFC <- logged[, 1] - logged[, 2]
abundance <- rowMeans(logged)
```

The presence of a distinct population in the discarded pool manifests as a set of genes that are strongly upregulated in `lost`. This includes PF4, PPBP and SDPR, which (spoiler alert!) indicates that there is a platelet population that has been discarded by `alt.discard`.  

```{r, fig.cap='Average counts across all discarded and retained cells in the PBMC dataset, after using a more stringent filter on the total UMI count. Each point represents a gene, with platelet-related genes highlighted in orange.'}
plot(abundance, logFC, xlab = "Average count", ylab = "Log-FC (lost/kept)", pch = 16)
platelet <- c("PF4", "PPBP", "SDPR")
points(abundance[platelet], logFC[platelet], col = "orange", pch = 16)
```

If we suspect that cell types have been incorrectly discarded by our QC procedure, the most direct solution is to relax the QC filters for metrics that are associated with genuine biological differences. For example, outlier detection can be relaxed by increasing nmads= in the isOutlier() calls. Of course, this increases the risk of retaining more low-quality cells and encountering the problems discussed in Section 6.1. The logical endpoint of this line of reasoning is to avoid filtering altogether, as discussed in Section 6.6.  

As an aside, it is worth mentioning that the true technical quality of a cell may also be correlated with its type. (This differs from a correlation between the cell type and the QC metrics, as the latter are our imperfect proxies for quality.) This can arise if some cell types are not amenable to dissociation or microfluidics handling during the scRNA-seq protocol. In such cases, it is possible to “correctly” discard an entire cell type during QC if all of its cells are damaged. Indeed, concerns over the computational removal of cell types during QC are probably minor compared to losses in the experimental protocol.  

## Marking low-quality cells  
The other option is to simply mark the low-quality cells as such and retain them in the downstream analysis. The aim here is to allow clusters of low-quality cells to form, and then to identify and ignore such clusters during interpretation of the results. This approach avoids discarding cell types that have poor values for the QC metrics, giving users an opportunity to decide whether a cluster of such cells represents a genuine biological state.  

```{r}
colData(sce.416b) <- cbind(colData(sce.416b), reasons)
marked <- sce.416b
```

The downside is that it shifts the burden of QC to the interpretation of the clusters, which is already the bottleneck in scRNA-seq data analysis (Chapters 10, 11 and 12). Indeed, if we do not trust the QC metrics, we would have to distinguish between genuine cell types and low-quality cells based only on marker genes, and this is not always easy due to the tendency of the latter to “express” interesting genes (Section 6.1). Retention of low-quality cells also compromises the accuracy of the variance modelling, requiring, e.g., use of more PCs to offset the fact that the early PCs are driven by differences between low-quality and other cells.  

For routine analyses, we suggest performing removal by default to avoid complications from low-quality cells. This allows most of the population structure to be characterized with no - or, at least, fewer - concerns about its validity. Once the initial analysis is done, and if there are any concerns about discarded cell types (Section 6.5), a more thorough re-analysis can be performed where the low-quality cells are only marked. This recovers cell types with low RNA content, high mitochondrial proportions, etc. that only need to be interpreted insofar as they “fill the gaps” in the initial analysis.  


# Chapter 7 Normalization  
## Motivation  
Systematic differences in sequencing coverage between libraries are often observed in single-cell RNA sequencing data (Stegle, Teichmann, and Marioni 2015). **They typically arise from technical differences in cDNA capture or PCR amplification efficiency across cells, attributable to the difficulty of achieving consistent library preparation with minimal starting material**. Normalization aims to remove these differences such that they do not interfere with comparisons of the expression profiles between cells. This ensures that any observed heterogeneity or differential expression within the cell population are driven by biology and not technical biases.  

At this point, it is worth noting the difference between normalization and batch correction (Chapter 28.8). Normalization occurs regardless of the batch structure and only considers technical biases, while batch correction - as the name suggests - only occurs across batches and must consider both technical biases and biological differences. Technical biases tend to affect genes in a similar manner, or at least in a manner related to their biophysical properties (e.g., length, GC content), while biological differences between batches can be highly unpredictable. As such, these two tasks involve different assumptions and generally involve different computational methods (though some packages aim to perform both steps at once, e.g., zinbwave). Thus, it is important to avoid conflating “normalized” and “batch-corrected” data, as these usually refer to different things.  

We will mostly focus our attention on scaling normalization, which is the simplest and most commonly used class of normalization strategies. This involves dividing all counts for each cell by a cell-specific scaling factor, often called a “size factor” (Anders and Huber 2010). The assumption here is that any cell-specific bias (e.g., in capture or amplification efficiency) affects all genes equally via scaling of the expected mean count for that cell. The size factor for each cell represents the estimate of the relative bias in that cell, so division of its counts by its size factor should remove that bias. The resulting “normalized expression values” can then be used for downstream analyses such as clustering and dimensionality reduction. To demonstrate, we will use the Zeisel et al. (2015) dataset from the `scRNAseq` package.  

```{r}
library(scRNAseq)
sce.zeisel <- ZeiselBrainData()
sce.zeisel <- readRDS("data/sce.zeisel.rds")

library(scater)
sce.zeisel <- aggregateAcrossFeatures(x = sce.zeisel, 
                                      ids = sub("_loc[0-9]+$", "", rownames(sce.zeisel)))

# gene annotation  
library(org.Mm.eg.db)
rowData(sce.zeisel)$Ensembl <- mapIds(org.Mm.eg.db, 
                                      keys = rownames(sce.zeisel), 
                                      keytype = "SYMBOL", 
                                      column = "ENSEMBL")

# quality control
stats <- perCellQCMetrics(sce.zeisel, 
                          subsets = list(Mt = rowData(sce.zeisel)$featureType == "mito"))
qc <- quickPerCellQC(stats, percent_subsets = c("altexps_ERCC_percent", "subsets_Mt_percent"))
sce.zeisel <- sce.zeisel[, !qc$discard]
```

## Library size normalization  
Library size normalization is the simplest strategy for performing scaling normalization. We define the library size as the total sum of counts across all genes for each cell, the expected value of which is assumed to scale with any cell-specific biases. The “library size factor” for each cell is then directly proportional to its library size where the proportionality constant is defined such that the mean size factor across all cells is equal to 1. This definition ensures that the normalized expression values are on the same scale as the original counts, which is useful for interpretation - especially when dealing with transformed data (see Section 7.5.1).  

```{r}
library(scater)
lib.sf.zeisel <- librarySizeFactors(sce.zeisel)
summary(lib.sf.zeisel)
```

In the Zeisel brain data, the library size factors differ by up to 10-fold across cells (Figure 7.1). This is typical of the variability in coverage in scRNA-seq data.  

```{r, fig.cap='Distribution of size factors derived from the library size in the Zeisel brain dataset.'}
hist(log10(lib.sf.zeisel), xlab = "Log10[size factor]", col = "grey80", breaks = 20)
```

Strictly speaking, the use of library size factors assumes that there is no “imbalance” in the differentially expressed (DE) genes between any pair of cells. That is, any upregulation for a subset of genes is cancelled out by the same magnitude of downregulation in a different subset of genes. This ensures that the library size is an unbiased estimate of the relative cell-specific bias by avoiding composition effects (Robinson and Oshlack 2010). However, balanced DE is not generally present in scRNA-seq applications, which means that library size normalization may not yield accurate normalized expression values for downstream analyses.  

**In practice, normalization accuracy is not a major consideration for exploratory scRNA-seq data analyses. Composition biases do not usually affect the separation of clusters, only the magnitude - and to a lesser extent, direction - of the log-fold changes between clusters or cell types**. As such, library size normalization is usually sufficient in many applications where the aim is to identify clusters and the top markers that define each cluster.  

## Normalization by deconvolution  
As previously mentioned, composition biases will be present when any unbalanced differential expression exists between samples. Consider the simple example of two cells where a single gene **X** is upregulated in one cell **A** compared to the other cell **B**. This upregulation means that either (i) more sequencing resources are devoted to **X** in **A**, thus decreasing coverage of all other non-DE genes when the total library size of each cell is experimentally fixed (e.g., due to library quantification); or (ii) the library size of **A** increases when **X** is assigned more reads or UMIs, increasing the library size factor and yielding smaller normalized expression values for all non-DE genes. In both cases, the net effect is that non-DE genes in **A** will incorrectly appear to be downregulated compared to **B**.  

The removal of composition biases is a well-studied problem for bulk RNA sequencing data analysis. Normalization can be performed with the `estimateSizeFactorsFromMatrix()` function in the `DESeq2` package (Anders and Huber 2010; Love, Huber, and Anders 2014) or with the `calcNormFactors()` function (Robinson and Oshlack 2010) in the `edgeR` package. These assume that most genes are not DE between cells. Any systematic difference in count size across the non-DE majority of genes between two cells is assumed to represent bias that is used to compute an appropriate size factor for its removal.  

However, single-cell data can be problematic for these bulk normalization methods due to the dominance of low and zero counts. To overcome this, we pool counts from many cells to increase the size of the counts for accurate size factor estimation (Lun, Bach, and Marioni 2016). Pool-based size factors are then “deconvolved” into cell-based factors for normalization of each cell’s expression profile. This is performed using the `calculateSumFactors()` function from `scran`.  

```{r}
library(scran)
set.seed(100)

clust.zeisel <- quickCluster(sce.zeisel)
table(clust.zeisel)
```

```{r}
deconv.sf.zeisel <- calculateSumFactors(sce.zeisel, cluster = clust.zeisel)
summary(deconv.sf.zeisel)
```

We use a pre-clustering step with `quickCluster()` where cells in each cluster are normalized separately and the size factors are rescaled to be comparable across clusters. This avoids the assumption that most genes are non-DE across the entire population - only a non-DE majority is required between pairs of clusters, which is a weaker assumption for highly heterogeneous populations. By default, `quickCluster()` will use an approximate algorithm for PCA based on methods from the `irlba` package. The approximation relies on stochastic initialization so we need to set the random seed (via `set.seed()`) for reproducibility.  

We see that the deconvolution size factors exhibit cell type-specific deviations from the library size factors in Figure 7.2. This is consistent with the presence of composition biases that are introduced by strong differential expression between cell types. Use of the deconvolution size factors adjusts for these biases to improve normalization accuracy for downstream applications.  

```{r, fig.cap='Deconvolution size factor for each cell in the Zeisel brain dataset, compared to the equivalent size factor derived from the library size. The red line corresponds to identity between the two size factors.'}
plot(lib.sf.zeisel, deconv.sf.zeisel, 
     xlab = "library size factor", 
     ylab = "Deconvolution size factor", 
     log = "xy", 
     pch = 16, 
     col = as.integer(factor(sce.zeisel$level1class)))
abline(a = 0, b = 1, col = "red")
```

**Accurate normalization is most important for procedures that involve estimation and interpretation of per-gene statistics**. For example, composition biases can compromise DE analyses by systematically shifting the log-fold changes in one direction or another. However, it tends to provide less benefit over simple library size normalization for cell-based analyses such as clustering. The presence of composition biases already implies strong differences in expression profiles, so changing the normalization strategy is unlikely to affect the outcome of a clustering procedure.  

## Normalization by spike-in  
Spike-in normalization is based on the assumption that the same amount of spike-in RNA was added to each cell (A. T. L. Lun et al. 2017). Systematic differences in the coverage of the spike-in transcripts can only be due to cell-specific biases, e.g., in capture efficiency or sequencing depth. To remove these biases, we equalize spike-in coverage across cells by scaling with “spike-in size factors”. **Compared to the previous methods, spike-in normalization requires no assumption about the biology of the system (i.e., the absence of many DE genes). Instead, it assumes that the spike-in transcripts were (i) added at a constant level to each cell, and (ii) respond to biases in the same relative manner as endogenous genes**.  

**Practically, spike-in normalization should be used if differences in the total RNA content of individual cells are of interest and must be preserved in downstream analyses**. For a given cell, an increase in its overall amount of endogenous RNA will not increase its spike-in size factor. This ensures that the effects of total RNA content on expression across the population will not be removed upon scaling. **By comparison, the other normalization methods described above will simply interpret any change in total RNA content as part of the bias and remove it**.  

We demonstrate the use of spike-in normalization on a different dataset involving T cell activation after stimulation with T cell recepter ligands of varying affinity (Richard et al. 2018).  

```{r}
library(scRNAseq)
# sce.richard <- RichardTCellData()
# saveRDS(sce.richard)
sce.richard <- readRDS("data/sce.richard.rds")
sce.richard <- sce.richard[, sce.richard$`single cell quality` == 'OK']
```

We apply the `computeSpikeFactors()` method to estimate spike-in size factors for all cells. This is defined by converting the total spike-in count per cell into a size factor, using the same reasoning as in `librarySizeFactors()`. Scaling will subsequently remove any differences in spike-in coverage across cells.  

```{r}
sce.richard <- computeSpikeFactors(x = sce.richard, spikes = "ERCC")
summary(sizeFactors(sce.richard))
```

We observe a positive correlation between the spike-in size factors and deconvolution size factors within each treatment condition (Figure 7.3), indicating that they are capturing similar technical biases in sequencing depth and capture efficiency. However, we also observe that increasing stimulation of the T cell receptor - in terms of increasing affinity or time - results in a decrease in the spike-in factors relative to the library size factors. This is consistent with an increase in biosynthetic activity and total RNA content during stimulation, which reduces the relative spike-in coverage in each library (thereby decreasing the spike-in size factors) but increases the coverage of endogenous genes (thus increasing the library size factors).  

```{r, fig.cap='Size factors from spike-in normalization, plotted against the library size factor fro all cells in the T cell dataset. Each plot represents a different ligand treatment and each point is a cell coloured according by time from stimulation.'}
to.plot <- data.frame(
    DeconvFactor = calculateSumFactors(sce.richard), 
    SpikeFactor = sizeFactors(sce.richard), 
    Stimulus = sce.richard$stimulus, 
    Time = sce.richard$time
)

ggplot(to.plot, aes(x = DeconvFactor, y = SpikeFactor, color = Time)) +
    geom_point() +
    facet_wrap(~Stimulus) +
    scale_x_log10() +
    scale_y_log10() +
    geom_abline(intercept = 0, slope = 1, color = "red") +
    theme(legend.position = "top", 
          strip.text = element_text(size = 7))
```

The differences between these two sets of size factors have real consequences for downstream interpretation. If the spike-in size factors were applied to the counts, the expression values in unstimulated cells would be scaled up while expression in stimulated cells would be scaled down. However, the opposite would occur if the deconvolution size factors were used. This can manifest as shifts in the magnitude and direction of DE between conditions when we switch between normalization strategies, as shown below for *Malat1*.  

```{r, fig.cap='Distribution of log-normalized expression values for Malat1 after normalization with the deconvolution (left) or spike-in size factor (right). Cells are stratified by the ligand affinity and colored by the time stimulation.'}
# see below for explanation of LogNormCounts()
sce.richard.deconv <- logNormCounts(sce.richard, size_factors = to.plot$DeconvFactor)
sce.richard.spike <- logNormCounts(sce.richard, size_factors = to.plot$SpikeFactor)

cowplot::plot_grid(plotlist = list(
    plotExpression(sce.richard.deconv, x = "stimulus", 
                   colour_by = "time", features = "ENSMUSG00000092341") +
        theme(axis.text.x = element_text(angle = 90)) +
        ggtitle("After deconvolution"), 
    plotExpression(sce.richard.spike, x = "stimulus", 
                   colour_by = "time", features = "ENSMUSG00000092341") +
        theme(axis.text.x = element_text(angle = 90)) +
        ggtitle("After spike-in normalization")
), 
ncol = 2)
```

Whether or not total RNA content is relevant – and thus, the choice of normalization strategy – depends on the biological hypothesis. In most cases, changes in total RNA content are not interesting and can be normalized out by applying the library size or deconvolution factors. However, this may not always be appropriate if differences in total RNA are associated with a biological process of interest, e.g., cell cycle activity or T cell activation. Spike-in normalization will preserve these differences such that any changes in expression between biological groups have the correct sign.  

**However**! Regardless of whether we care about total RNA content, it is critical that the spike-in transcripts are normalized using the spike-in size factors. Size factors computed from the counts for endogenous genes should not be applied to the spike-in transcripts, precisely because the former captures differences in total RNA content that are not experienced by the latter. Attempting to normalize the spike-in counts with the gene-based size factors will lead to over-normalization and incorrect quantification. Thus, if normalized spike-in data is required, we must compute a separate set of size factors for the spike-in transcripts; this is automatically performed by functions such as `modelGeneVarWithSpikes()`.

## Applying the size factors  
### Scaling and log-transforming  



















# Resources  
- http://bioconductor.org/books/release/OSCA/  




---
title: "Chapter 10 Clustering"
author: "yincy"
date: "2/28/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
```

# Chapter 10 Clustering  
## Motivation  
Clustering is an unsupervised learning procedure that is used in scRNA-seq data analysis to empirically define groups of cells with similar expression profiles. Its primary purpose is to summarize the data in a digestible format for human interpretation. This allows us to describe population heterogeneity in terms of discrete labels that are easily understood, rather than attempting to comprehend the high-dimensional manifold on which the cells truly reside. After annotation based on marker genes, the clusters can be treated as proxies for more abstract biological concepts such as cell types or states. Clustering is thus a critical step for extracting biological insights from scRNA-seq data. Here, we demonstrate the application of several commonly used methods with the 10X PBMC dataset.  

```{r}
# loading 
library(DropletUtils)

fname <- "/home/yincy/git/Data/Bioconductor/Single-Cell/osca/pbmc4k/raw_gene_bc_matrices/GRCh38/"
sce.pbmc <- read10xCounts(samples = fname, col.names = T)

# gene annotation
library(scater)
rownames(sce.pbmc) <- uniquifyFeatureNames(
    ID = rowData(sce.pbmc)$ID, 
    names = rowData(sce.pbmc)$Symbol
)

library(EnsDb.Hsapiens.v86)
location <- mapIds(EnsDb.Hsapiens.v86, 
                   keys = rowData(sce.pbmc)$ID, 
                   keytype = "GENEID", 
                   column = "SEQNAME")

# cell detection 
set.seed(100)
e.out <- emptyDrops(counts(sce.pbmc))
sce.pbmc <- sce.pbmc[, which(e.out$FDR <= 0.001)]

# quality control
stats <- perCellQCMetrics(sce.pbmc, subsets = list(Mito = which(location == "MT")))
high.mito <- isOutlier(stats$subsets_Mito_percent, type = "higher")
sce.pbmc <- sce.pbmc[, !high.mito]

# normalization
library(scran)
set.seed(1000)
clusters <- quickCluster(sce.pbmc)
sce.pbmc <- computeSumFactors(sce.pbmc, cluster = clusters)
sce.pbmc <- logNormCounts(sce.pbmc)

# variance modelling
set.seed(1001)
dec.pbmc <- modelGeneVarByPoisson(x = sce.pbmc)
top.pbmc <- getTopHVGs(stats = dec.pbmc, prop = 0.1)

# dimensionality reduction
set.seed(10000)
sce.pbmc <- denoisePCA(x = sce.pbmc, subset.row = top.pbmc, technical = dec.pbmc)

set.seed(100000)
sce.pbmc <- runTSNE(sce.pbmc, dimred = "PCA")

set.seed(1000000)
sce.pbmc <- runUMAP(sce.pbmc, dimred = "PCA")
```

## What is the "true clustering"?  
At this point, it is worth stressing the distinction between clusters and cell types. The former is an empirical construct while the latter is a biological truth (albeit a vaguely defined one). For this reason, questions like “what is the true number of clusters?” are usually meaningless. We can define as many clusters as we like, with whatever algorithm we like - each clustering will represent its own partitioning of the high-dimensional expression space, and is as “real” as any other clustering.  

A more relevant question is “how well do the clusters approximate the cell types?” Unfortunately, this is difficult to answer given the context-dependent interpretation of biological truth. Some analysts will be satisfied with resolution of the major cell types; other analysts may want resolution of subtypes; and others still may require resolution of different states (e.g., metabolic activity, stress) within those subtypes. Moreover, two clusterings can be highly inconsistent yet both valid, simply partitioning the cells based on different aspects of biology. Indeed, asking for an unqualified “best” clustering is akin to asking for the best magnification on a microscope without any context.  

**It is helpful to realize that clustering, like a microscope, is simply a tool to explore the data. We can zoom in and out by changing the resolution of the clustering parameters, and we can experiment with different clustering algorithms to obtain alternative perspectives of the data. This iterative approach is entirely permissible for data exploration, which constitutes the majority of all scRNA-seq data analyses**.  

## Graph-based clustering  
### Background  
Popularized by its use in Seurat, graph-based clustering is a flexible and scalable technique for clustering large scRNA-seq datasets. We first build a graph where each node is a cell that is connected to its nearest neighbors in the high-dimensional space. Edges are weighted based on the similarity between the cells involved, with higher weight given to cells that are more closely related. We then apply algorithms to identify “communities” of cells that are more connected to cells in the same community than they are to cells of different communities. Each community represents a cluster that we can use for downstream interpretation.  

*The major advantage of graph-based clustering lies in its scalability*. It only requires a k-nearest neighbor search that can be done in log-linear time on average, in contrast to hierachical clustering methods with runtimes that are quadratic with respect to the number of cells. *Graph construction avoids making strong assumptions about the shape of the clusters or the distribution of cells within each cluster, compared to other methods like k-means (that favor spherical clusters) or Gaussian mixture models (that require normality)*. From a practical perspective, each cell is forcibly connected to a minimum number of neighboring cells, which reduces the risk of generating many uninformative clusters consisting of one or two outlier cells.

The main drawback of graph-based methods is that, after graph construction, no information is retained about relationships beyond the neighboring cells1. This has some practical consequences in datasets that exhibit differences in cell density, as more steps through the graph are required to move the same distance through a region of higher cell density. From the perspective of community detection algorithms, this effect “inflates” the high-density regions such that any internal substructure or noise is more likely to cause formation of subclusters. The resolution of clustering thus becomes dependent on the density of cells, which can occasionally be misleading if it overstates the heterogeneity in the data.  

### Implementation  
There are several considerations in the practical execution of a graph-based clustering method: 

- How many neighbors are considered when constructing the graph.  
- What scheme is used to weight the edges.  
- Which community detection algorithm is used to define the clusters.  

For example, the following code uses the 10 nearest neighbors of each cell to construct a shared nearest neighbor graph. Two cells are connected by an edge if any of their nearest neighbors are shared, with the edge weight defined from the highest average rank of the shared neighbors (Xu and Su 2015). The Walktrap method from the `igraph` package is then used to identify communities. All calculations are performed using the top PCs to take advantage of data compression and denoising.  

```{r}
library(scran)

g <- buildSNNGraph(sce.pbmc, k = 10, use.dimred = "PCA")
clust <- igraph::cluster_walktrap(g)$membership
table(clust)
```

Alternatively, users may prefer to use the `clusterRows()` function from the `bluster` package. This calls the exact same series of functions when run in graph-based mode with the `NNGraphParam()` argument; however, it is often more convenient if we want try out different clustering procedures, as we can simply change the second argument to use a different set of parameters or a different algorithm altogether.  

```{r}
library(bluster)
clust2 <- clusterRows(x = reducedDim(sce.pbmc, "PCA"), BLUSPARAM = NNGraphParam())
table(clust2)
```

We assign the cluster assignments back into our `SingleCellExperiment` object as a factor in the column metadata. This allows us to conveniently visualize the distribution of clusters in a t-SNE plot.  

```{r}
library(scater)
colLabels(sce.pbmc) <- factor(clust)
plotReducedDim(sce.pbmc, 
               dimred = "TSNE", 
               colour_by = "label")
```

One of the most important parameters is k, the number of nearest neighbors used to construct the graph. This controls the resolution of the clustering where higher k yields a more inter-connected graph and broader clusters. Users can exploit this by experimenting with different values of k to obtain a satisfactory resolution.  

```{r}
# more resolved
g.5 <- buildSNNGraph(sce.pbmc, k = 5, use.dimred  = "PCA")
clust.5 <- igraph::cluster_walktrap(g.5)$membership
table(clust.5)

# less resolved 
g.50 <- buildSNNGraph(sce.pbmc, k = 50, use.dimred = "PCA")
clust.50 <- igraph::cluster_walktrap(g.50)$membership
table(clust.50)
```

```{r}
reducedDim(sce.pbmc, "nicely") <- igraph::layout_nicely(g)
plotReducedDim(sce.pbmc, dimred = "nicely", colour_by = "label")
```

### Other parameters  
Further tweaking can be performed by changing the edge weighting scheme during graph construction. Setting `type="number"` will weight edges based on the number of nearest neighbors that are shared between two cells. Similarly, `type="jaccard"` will weight edges according to the Jaccard index of the two sets of neighbors. We can also disable weighting altogether by using `buildKNNGraph()`, which is occasionally useful for downstream graph operations that do not support weights.  

```{r}
g.num <- buildSNNGraph(sce.pbmc, use.dimred = "PCA", type = "number")
g.jaccard <- buildSNNGraph(sce.pbmc, use.dimred = "PCA", type = "jaccard")
g.none <- buildKNNGraph(sce.pbmc, use.dimred = "PCA")
```

All of these g variables are graph objects from the `igraph` package and can be used with any of the community detection algorithms provided by `igraph`. We have already mentioned the Walktrap approach, but many others are available to choose from.  

```{r}
clust.louvain <- igraph::cluster_louvain(graph = g)$membership
clust.infomap <- igraph::cluster_infomap(graph = g)$membership
clust.fast <- igraph::cluster_fast_greedy(graph = g)$membership
clust.labprop <- igraph::cluster_label_prop(graph = g)$membership
clust.eigen <- igraph::cluster_leading_eigen(graph = g)$membership
```

It is then straightforward to compare two clustering strategies to see how they differ. For example, Figure below suggests that Infomap yields finer clusters than Walktrap while fast-greedy yields coarser clusters.  

```{r}
library(pheatmap)

# using a large pseudo-count for a smoother color transition between 0 and 1 cell in each 'tab'  

tab <- table(paste("Infomap", clust.infomap), 
             paste("Walktrap", clust))

ivm <- pheatmap(log10(tab + 1), 
                main = "Infomap vs Walktrap", 
                color = viridis::viridis(100), 
                silent = T)

tab <- table(paste("Fast", clust.fast), 
             paste("Walktrap", clust))
fvw <- pheatmap(log10(tab + 10), 
                main = "Fast-greedy vs Walktrap", 
                color = viridis::viridis(100), 
                silent = T)

cowplot::plot_grid(plotlist = list(ivm[[4]], fvw[[4]]), 
                   ncol = 2)
```

Pipelines involving `scran` default to rank-based weights followed by Walktrap clustering. In contrast, `Seurat` uses Jaccard-based weights followed by Louvain clustering. Both of these strategies work well, and it is likely that the same could be said for many other combinations of weighting schemes and community detection algorithms.  

Some community detection algorithms operate by agglomeration and thus can be used to construct a hierarchical dendrogram based on the pattern of merges between clusters. The dendrogram itself is not particularly informative as it simply describes the order of merge steps performed by the algorithm; unlike the dendrograms produced by hierarchical clustering (Section 10.5), it does not capture the magnitude of differences between subpopulations. However, it does provide a convenient avenue for manually tuning the clustering resolution by generating nested clusterings using the `cut_at()` function, as shown below.  

```{r}
community.walktrap <- igraph::cluster_walktrap(g)
igraph::cut_at(community.walktrap, n = 5) %>% table
```

```{r}
igraph::cut_at(community.walktrap, n = 20) %>% table
```

If `cut_at()`-like functionality is desired for non-hierarchical methods, `bluster` provides a `mergeCommunities()` function to retrospectively tune the clustering resolution. This function will greedily merge pairs of clusters until a specified number of clusters is achieved, where pairs are chosen to maximize the modularity at each merge step.  

```{r}
community.louvain <- igraph::cluster_louvain(g)
community.louvain$membership %>% table
```

```{r}
try(igraph::cut_at(community.louvain, n=10)) 
```


```{r}
merged <- mergeCommunities(graph = g, clusters = community.louvain$membership, number = 10)
merged %>% table
```

### Assessing cluster separation  
When dealing with graphs, the modularity is a natural metric for evaluating the separation between communities/clusters. This is defined as the (scaled) difference between the observed total weight of edges between nodes in the same cluster and the expected total weight if edge weights were randomly distributed across all pairs of nodes. Larger modularity values indicate that there most edges occur within clusters, suggesting that the clusters are sufficiently well separated to avoid edges forming between neighboring cells in different clusters.  

The standard approach is to report a single modularity value for a clustering on a given graph. This is useful for comparing different clusterings on the same graph - and indeed, some community detection algorithms are designed with the aim of maximizing the modularity - but it is less helpful for interpreting a given clustering. Rather, we use the `pairwiseModularity()` function from `bluster` with `as.ratio=TRUE`, which returns the ratio of the observed to expected sum of weights between each pair of clusters. We use the ratio instead of the difference as the former is less dependent on the number of cells in each cluster.  

```{r}
ratio <- pairwiseModularity(graph = g, clusters = clust, as.ratio = T)
clust %>% table
ratio %>% dim
```

In this matrix, each row/column corresponds to a cluster and each entry contains the ratio of the observed to total weight of edges between cells in the respective clusters. A dataset containing well-separated clusters should contain most of the observed total weight on the diagonal entries, i.e., most edges occur between cells in the same cluster. Indeed, concentration of the weight on the diagonal of (Figure 10.4) indicates that most of the clusters are well-separated, while some modest off-diagonal entries represent closely related clusters with more inter-connecting edges.  

```{r}
library(pheatmap)
library(viridis)

pheatmap(log2(ratio + 1), 
         cluster_rows = F, 
         cluster_cols = F, 
         color = viridis(n = 100))
```

One useful approach is to use the `ratio` matrix to form another graph where the nodes are clusters rather than cells. Edges between nodes are weighted according to the `ratio` of observed to expected edge weights between cells in those clusters. We can then repeat our graph operations on this new cluster-level graph to explore the relationships between clusters. For example, we could obtain clusters of clusters, or we could simply create a new cluster-based layout for visualization (Figure 10.5). This is analogous to the “graph abstraction” approach described by Wolf et al. (2017), which can be used to identify trajectories in the data based on high-weight paths between clusters.  

```{r}
cluster.gr <- igraph::graph_from_adjacency_matrix(adjmatrix = log2(ratio + 1), 
                                                  mode = "upper", 
                                                  weighted = T, 
                                                  diag = F)

# increasing the weight to increase the visibility of the lines
set.seed(11001010)
plot(cluster.gr, 
     edge.width = igraph::E(cluster.gr)$weight * 5, 
     layout = igraph::layout_with_lgl)
```

Incidentally, some readers may have noticed that all `igraph` commands were prefixed with igraph::. We have done this deliberately to avoid bringing `igraph::normalize` into the global namespace. Rather unfortunately, this `normalize` function accepts any argument and returns `NULL`, which causes difficult-to-diagnose bugs when it overwrites `normalize` from `BiocGenerics`.  


## K-means clustering
### Background
k-means clustering is a classic technique that aims to partition cells into  
k clusters. Each cell is assigned to the cluster with the closest centroid, which is done by minimizing the within-cluster sum of squares using a random starting configuration for the k centroids. The main advantage of this approach lies in its speed, given the simplicity and ease of implementation of the algorithm. However, it suffers from a number of serious shortcomings that reduce its appeal for obtaining interpretable clusters:  

- It implicitly favors spherical clusters of equal radius. This can lead to unintuitive partitionings on real datasets that contain groupings with irregular sizes and shapes.  

- The number of clusters k must be specified beforehand and represents a hard cap on the resolution of the clustering.. For example, setting k to be below the number of cell types will always lead to co-clustering of two cell types, regardless of how well separated they are. In contrast, other methods like graph-based clustering will respect strong separation even if the relevant resolution parameter is set to a low value.  

- It is dependent on the randomly chosen initial coordinates. This requires multiple runs to verify that the clustering is stable.  

That said, k-means clustering is still one of the best approaches for sample-based data compression. In this application, we set k to a large value such as the square root of the number of cells to obtain fine-grained clusters. These are not meant to be interpreted directly, but rather, the centroids are treated as “samples” for further analyses. The idea here is to obtain a single representative of each region of the expression space, reducing the number of samples and computational work in later steps like, e.g., trajectory reconstruction (Ji and Ji 2016). This approach will also eliminate differences in cell density across the expression space, ensuring that the most abundant cell type does not dominate downstream results.  

### Base implementation  
Base R provides the kmeans() function that does as its name suggests. We call this on our top PCs to obtain a clustering for a specified number of clusters in the centers= argument, after setting the random seed to ensure that the results are reproducible. In general, the k-means clusters correspond to the visual clusters on the t-SNE plot in Figure 10.6, though there are some divergences that are not observed in, say, Figure 10.1. (This is at least partially due to the fact that t-SNE is itself graph-based and so will naturally agree more with a graph-based clustering strategy.)  

```{r}
set.seed(100)

clust.kmeans <- kmeans(reducedDim(x = sce.pbmc, type = "PCA"), centers = 10)
clust.kmeans$cluster %>% table
```

```{r}
colLabels(sce.pbmc) <- factor(clust.kmeans$cluster)
plotReducedDim(sce.pbmc, dimred = "TSNE", colour_by = "label")
```

If we were so inclined, we could obtain a “reasonable” choice of k by computing the gap statistic using methods from the cluster package. This is the log-ratio of the expected to observed within-cluster sum of squares, where the expected value is computed by randomly distributing cells within the minimum bounding box of the original data. A larger gap statistic represents a lower observed sum of squares - and thus better clustering - compared to a population with no structure. Ideally, we would choose the k that maximizes the gap statistic, but this is often unhelpful as the tendency of k-means to favor spherical clusters drives a large k to capture different cluster shapes. Instead, we choose the most parsimonious  
k beyond which the increases in the gap statistic are considered insignificant (Figure 10.7). It must be said, though, that this process is time-consuming and the resulting choice of  
k is not always stable.   

```{r}
library(cluster)

set.seed(110010101)
gaps <- clusGap(x = reducedDim(sce.pbmc, "PCA"), 
                FUNcluster = kmeans, 
                K.max = 20)
best.k <- maxSE(gaps$Tab[, "gap"], gaps$Tab[, "SE.sim"])
best.k
```

```{r}
plot(gaps$Tab[, "gap"], 
     xlab = "Number of clusters", 
     ylab = "Gap statistics")
abline(v = best.k, col = "red", lty = 2)
```

A more practical use of k-means is to deliberately set k to a large value to achieve overclustering. This will forcibly partition cells inside broad clusters that do not have well-defined internal structure. For example, we might be interested in the change in expression from one “side” of a cluster to the other, but the lack of any clear separation within the cluster makes it difficult to separate with graph-based methods, even at the highest resolution. k-means has no such problems and will readily split these broad clusters for greater resolution, though obviously one must be prepared for the additional work involved in interpreting a greater number of clusters.  

```{r}
set.seed(100)

clust.kmeans2 <- kmeans(reducedDim(sce.pbmc, "PCA"), 
                        centers = 20)
clust.kmeans2$cluster %>% table
```

```{r}
colLabels(sce.pbmc) <- factor(clust.kmeans2$cluster)
plotTSNE(sce.pbmc, colour_by = "label", text_by = "label", text_size = 3)
```

As an aside: if we were already using `clusterRows()` from bluster, we can easily switch to k-means clustering by supplying a `KmeansParam()` as the second argument. This requires the number of clusters as a fixed integer or as a function of the number of cells - the example below sets the number of clusters to the square root of the number of cells, which is an effective rule-of-thumb for vector quantization.  

```{r}
set.seed(10000)

sq.clusts <- clusterRows(reducedDim(sce.pbmc, "PCA"), 
                         BLUSPARAM = KmeansParam(centers = sqrt))

sq.clusts %>% levels()
```

### Assessing cluster separation
The within-cluster sum of squares (WCSS) for each cluster is the most relevant diagnostic for  k-means, given that the algorithm aims to find a clustering that minimizes the WCSS. Specifically, we use the WCSS to compute the root-mean-squared deviation (RMSD) that represents the spread of cells within each cluster. A cluster is more likely to have a low RMSD if it has no internal structure and is separated from other clusters (such that there are not many cells on the boundaries between clusters, which would result in a higher sum of squares from the centroid).  

```{r}
ncells <- tabulate(clust.kmeans2$cluster)
tab <- data.frame(
    wcss = clust.kmeans2$withinss, 
    ncells = ncells
)

tab$rms <- sqrt(tab$wcss/tab$ncells)
tab
```

To explore the relationships between k-means clusters, a natural approach is to compute distances between their centroids. This directly lends itself to visualization as a tree after hierarchical clustering.   

```{r, message=FALSE}
library(factoextra)
cent.tree <- hclust(d = dist(x = clust.kmeans2$centers), method = "ward.D2")
fviz_dend(cent.tree)
```


### In two-step procedures
As previously mentioned, k-means is most effective in its role of vector quantization, i.e., compressing adjacent cells into a single representative point. This allows k-means to be used as a prelude to more sophisticated and interpretable - but expensive - clustering algorithms. The `clusterRows()` function supports a “two-step” mode where k-means is initially used to obtain representative centroids that are subjected to graph-based clustering. Each cell is then placed in the same graph-based cluster that its k-means centroid was assigned to.  

```{r}
set.seed(0101010)

kgraph.clusters <- clusterRows(x = reducedDim(sce.pbmc, "PCA"), 
                               BLUSPARAM = TwoStepParam(
                                   first = KmeansParam(centers = 1000), 
                                   second = NNGraphParam(k = 5)
                               ))

kgraph.clusters %>% table
```

```{r}
plotTSNE(sce.pbmc, colour_by = I(kgraph.clusters), 
         text_by = I(kgraph.clusters), 
         text_size = 3)
```

The obvious benefit of this approach over direct graph-based clustering is the speed improvement. We avoid the need to identifying nearest neighbors for each cell and the construction of a large intermediate graph, while benefiting from the relative interpretability of graph-based clusters compared to those from k-means. This approach also mitigates the “inflation” effect discussed in Section 10.3. Each centroid serves as a representative of a region of space that is roughly similar in volume, ameliorating differences in cell density that can cause (potentially undesirable) differences in resolution.  

The choice of the number of k-means clusters (defined here by the `kmeans.clusters=` argument) determines the trade-off between speed and fidelity. Larger values provide a more faithful representation of the underlying distribution of cells, at the cost of requiring more computational work by the second-stage clustering procedure. Note that the second step operates on the centroids, so increasing `kmeans.clusters=` may have further implications if the second-stage procedure is sensitive to the total number of input observations. For example, increasing the number of centroids would require an concomitant increase in `k=` (the number of neighbors in graph construction) to maintain the same level of resolution in the final output.  


## Hierarchical clustering  
### Background
Hierarchical clustering is an ancient technique that aims to generate a dendrogram containing a hierarchy of samples. This is most commonly done by greedily agglomerating samples into clusters, then agglomerating those clusters into larger clusters, and so on until all samples belong to a single cluster. Variants of hierarchical clustering methods primarily differ in how they choose to perform the agglomerations. For example, complete linkage aims to merge clusters with the smallest maximum distance between their elements, while Ward’s method aims to minimize the increase in within-cluster variance.  

In the context of scRNA-seq, the main advantage of hierarchical clustering lies in the production of the dendrogram. This is a rich summary that describes the relationships between cells and subpopulations at various resolutions and in a quantitative manner based on the branch lengths. Users can easily “cut” the tree at different heights to define clusters with different granularity, where clusters defined at high resolution are guaranteed to be nested within those defined at a lower resolution. (Guaranteed nesting can be helpful for interpretation, as discussed in Section 10.7.) The dendrogram is also a natural representation of the data in situations where cells have descended from a relatively recent common ancestor.  

In practice, hierachical clustering is too slow to be used for anything but the smallest scRNA-seq datasets. Most variants require a cell-cell distance matrix that is prohibitively expensive to compute for many cells. Greedy agglomeration is also likely to result in a quantitatively suboptimal partitioning (as defined by the agglomeration measure) at higher levels of the dendrogram when the number of cells and merge steps is high. Nonetheless, we will still demonstrate the application of hierarchical clustering here, as it can occasionally be useful for squeezing more information out of datasets with very few cells.  

### Implementation  
As the PBMC dataset is too large, we will demonstrate on the 416B dataset instead.  

```{r}
library(scRNAseq)

sce.416b <- readRDS("/home/yincy/git/Data/Bioconductor/Single-Cell/osca/sce.416b.rds")
sce.416b$block <- factor(sce.416b$block)

# gene annotation
library(EnsDb.Mmusculus.v79)

rowData(sce.416b)$ensembl <- rownames(sce.416b)
rowData(sce.416b)$symbol <- mapIds(EnsDb.Mmusculus.v79, 
                                   keys = rownames(sce.416b), 
                                   keytype = "GENEID", 
                                   column = "SYMBOL")
rowData(sce.416b)$seqname <- mapIds(EnsDb.Mmusculus.v79, 
                                    keys = rownames(sce.416b), 
                                    keytype = "GENEID", 
                                    column = "SEQNAME")

library(scater)
rownames(sce.416b) <- uniquifyFeatureNames(
    ID = rowData(sce.416b)$ensembl, 
    names = rowData(sce.416b)$symbol
)

# quality control
mito <- which(rowData(sce.416b)$seqname == "MT")
stats <- perCellQCMetrics(sce.416b, subsets = list(Mt = mito))
qc <- quickPerCellQC(x = stats, 
                     percent_subsets = c("subsets_Mt_percent", "altexps_ERCC_percent"), 
                     batch = sce.416b$block)

sce.416b <- sce.416b[, !qc$discard]

# normalization
library(scran)

sce.416b <- computeSumFactors(sce.416b)
sce.416b <- logNormCounts(sce.416b)

# variance modeling
dec.416b <- modelGeneCV2WithSpikes(x = sce.416b, 
                                   spikes = "ERCC", 
                                   block = sce.416b$block)

chosen.hvgs <- getTopHVGs(dec.416b, prop = 0.1, var.field = "ratio")

# batch correction
library(limma)
assay(sce.416b, "corrected") <- removeBatchEffect(logcounts(sce.416b), 
                                                  design = model.matrix(~ sce.416b$phenotype), 
                                                  batch = sce.416b$block)

# dimensionality reduction
sce.416b <- runPCA(sce.416b, ncomponents = 10, 
                   subset_row = chosen.hvgs, 
                   exprs_values = "corrected", 
                   BSPARAM = BiocSingular::ExactParam())

set.seed(1010)
sce.416b <- runTSNE(sce.416b, dimred = "PCA", perplexity = 10)
```

We compute a cell-cell distance matrix using the top PCs and we apply hierarchical clustering with Ward’s method. The resulting tree in Figure 10.11 shows a clear split in the population caused by oncogene induction. While both Ward’s method and complete linkage (`hclust()`’s default) yield compact clusters, we prefer the former it is less affected by differences in variance between clusters.  

```{r}
dist.416b <- dist(reducedDim(sce.416b, "PCA"))
tree.416b <- hclust(dist.416b, method = "ward.D2")

library(dendextend)
tree.416b$labels <- seq_along(tree.416b$labels)
dend <- as.dendrogram(tree.416b, hang = 0.1)

combined.fac <- paste(sce.416b$block, ".", sub(" .*", "", sce.416b$phenotype), sep = "")

labels_colors(dend) <- c(
    `20160113.wild` = "blue", 
    `20160113.induced` = "red", 
    `20160325.wild` = "dodgerblue", 
    `20160325.induced`  ="salmon"
)[combined.fac][order.dendrogram(dend)]
```

```{r}
library(factoextra)
fviz_dend(dend, k = 2, rect = T, rect_fill = T)
```

To obtain explicit clusters, we “cut” the tree by removing internal branches such that every subtree represents a distinct cluster. This is most simply done by removing internal branches above a certain height of the tree, as performed by the cutree() function. A more sophisticated variant of this approach is implemented in the `dynamicTreeCut` package, which uses the shape of the branches to obtain a better partitioning for complex dendrograms.  

```{r}
library(dynamicTreeCut)

# minClusterSize needs to be turned down for small  datasets
# deepSplit controls the resolution of the partitioning

clust.416b <- cutreeDynamic(dendro = tree.416b, 
                            distM = as.matrix(dist.416b), 
                            minClusterSize = 10, 
                            deepSplit = 1)

clust.416b %>% table
```

```{r}
labels_colors(dend) <- clust.416b[order.dendrogram(dend)]
plot(dend)
```

This generally corresponds well to the grouping of cells on a t-SNE plot (Figure 10.13). The exception is cluster 2, which is split across two visual clusters in the plot. We attribute this to a distortion introduced by t-SNE rather than inappropriate behavior of the clustering algorithm, based on the examination of some later diagnostics.

```{r}
colLabels(sce.416b) <- factor(clust.416b)
plotReducedDim(sce.416b, dimred = "TSNE", colour_by = "label")
```

Note that the series of calls required to obtain the clusters is also wrapped by clusterRows() for more convenient execution. In this case, we can reproduce clust.416b with the following:  

```{r}
clust.416b.again <- clusterRows(reducedDim(sce.416b, "PCA"), 
                                BLUSPARAM = HclustParam(method = "ward.D2", 
                                                        cut.dynamic = T, 
                                                        minClusterSize = 10, 
                                                        deepSplit = 1))

clust.416b.again %>% table
```

### Assessing cluster separation
We check the separation of the clusters using the silhouette width (Figure 10.14). For each cell, we compute the average distance to all cells in the same cluster. We also compute the average distance to all cells in another cluster, taking the minimum of the averages across all other clusters. The silhouette width for each cell is defined as the difference between these two values divided by their maximum. Cells with large positive silhouette widths are closer to other cells in the same cluster than to cells in different clusters.  

Each cluster would ideally contain large positive silhouette widths, indicating that it is well-separated from other clusters. This is indeed the case in Figure 10.14 - and in fact, cluster 2 has the largest width of all, indicating that it is a more coherent cluster than portrayed in Figure 10.13. Smaller widths can arise from the presence of internal subclusters, which inflates the within-cluster distance; or overclustering, where cells at the boundary of a partition are closer to the neighboring cluster than their own cluster.  

```{r}
sil <- silhouette(clust.416b, dist = dist.416b)
plot(sil)
```

For a more detailed examination, we identify the closest neighboring cluster for cells with negative widths. This provides a perspective on the relationships between clusters that is closer to the raw data than the dendrogram in Figure 10.12.  

```{r}
neg.widths <- sil[, 3] < 0
table(Cluster = sil[neg.widths, 1], Neighbor = sil[neg.widths, 2]) 
```

The average silhouette width across all cells can also be used to choose clustering parameters. The aim is to maximize the average silhouette width in order to obtain well-separated clusters. This can be helpful to automatically obtain a “reasonable” clustering, though in practice, the clustering that yields the strongest separation often does not provide the most biological insight.  

## General-purpose cluster diagnostics
### Cluster separation, redux


 





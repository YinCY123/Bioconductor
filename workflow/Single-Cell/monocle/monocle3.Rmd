---
title: "monocle3"
author: "yincy"
date: "3/14/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Introduction  
Single-cell transcriptome sequencing (sc-RNA-seq) experiments allow us to discover new cell types and help us understand how they arise in development. The Monocle 3 package provides a toolkit for analyzing single-cell gene expression experiments.  

Monocle 3 can help you perform three main types of analysis:  

- **Clustering**, **classifying**, **and counting cells**. Single-cell RNA-Seq experiments allow you to discover new (and possible rare) subtypes of cells. Monocle 3 helps you identify them.  

- **Constructing single-cell trajectores**. In devolopment, diseae, and throughout life, cells transition from one state to another. Monocle 3 helps you discover these transitions.  

- **Differential expresion analysis**. Characterizing new cell types and states begins with comparisons to other, better understood cells. Monocle 3 includes a sophisticated, but easy-to-use system for differential expression.  

# Major updates in Monocle 3  
Monocle 3 has been re-engineered to analyze large, complex single-cell datasets. The algorithms at the core of Monocle 3 are highly scalable and can handle millions of cells. Monocle 3 adds some powerful new features that enable the analysis of organism- or embryo-scale experiments:  

- A better structured workflow to learn developmental trajectories.  
- Support for the UMAP algorithm to initialize trajectory inference.  
- Support for trajectories with multiple roots.  
- Ways to learn trajectories that have loops or points of convergence.  
- Algorithms that automatically partition cells to learn disjoint or parallel trajectories using ideas from "approximate graph abstraction".  
- A new statistical test for genes that have trajectory-dependent expression. This replaces both the old `differentialGeneTest()` function and `BEAM()`.  
- A 3D interface to visualize trajectories and gene expression.  

# Getting started with Monocle 3  
```{r, fig.cap="Workflow of monocle 3"}
knitr::include_graphics(path = "/home/yincy/git/Bioconductor/workflow/Single-Cell/monocle/figures/monocle-workflow.png")
```

# quik workflow  
#### store data into monocle 3's main class `cell_data_set`  
```{r}
cds <- new_cell_data_set(expression_matrix, 
                         cell_metadata, 
                         gene_metadata)

# normalize and pre-process 
cds <- preprocess_cds(cds, num_dim = 100)
```

#### remove batch effects  
You can subtracted unwatched batch effects or align cells from similar (but not exactly) the same conditions using several different methods in Monocle 3.  
```{r}
# remove batch effects with cell alignment  
cds <- align_cds(cds, alignment_group = "batch")
```

#### Cluster cells  
```{r}
# reduce the dimensions using UMAP  
cds <- reduce_dimension(cds)

# cluster cells  
cds <- cluster_cells(cds)
```

#### Order cells in pseudotime along a trajectory (optional)  
Now, put your cells in order by how much progress they've made through whatever process you're studying, such as differentiation, reprogramming, or an immune response.  
```{r}
# learn a graph  
cds <- lean_graph(cds)

# order cells
cds <- order_cells(cds)

plot_cells(cds)
```


#### Perform differential expression analysis (optional)  
Compare groups of cells in myriad ways to find differentially expressed genes, controlling for batch effects and treatments as you like:  
```{r}
# with regression  
gene_fits <- fit_models(cds, model_formula_str = "~ embryo.time")
fit_coefs <- coefficient_table(gene_fits)
emb_time_terms <- fit_coefs %>% filter(term == "embryo.time")
emb_time_terms <- emb_time_terms %>% mutate(q_value = p.adjust(p_value))
sig_genes <- emb_time_terms %>% filter(q_value < 0.05) %>% pull(gene_short_name)

# with graph autocorrelation  
pr_test_res <- graph_test(cds, neighbor_graph = "principal_graph", cores = 4)
pr_deg <- ids <- row.names(subset(pr_test_res, q_value < 0.05))
```


# Get Started   
```{r load required packages, message=FALSE}
library(monocle3)
library(tidyverse)
```


### Loading your data  
Monocle 3 takes as input cell by gene expression matrix. Monocle 3 is designed for use with absolute transcript counts (e.g. from UMI experiments). Monocle 3 works "out-of-the-box" with the transcript count matrices produced by `Cell Ranger`, the software pipeline for analyzing experiments from the 10X Genomics Chromium instrument. Monocle 3 also works well with data from other RNA-Seq workflows such as `sci-RNA-Seq` and instruments like the Biorad ddSEQ.  


### The cell_data_set class  
Monocle holds single-cell expression data in objects of the `cell_data_set` class. The class is derived from the Bioconductor `SingleCellExperiment` class, which provides a common interface familiar to those who have analyzed other single-cell experiments with Bioconductor. The class requires three input files:  

- `expression_matrix`, a numeric matrix of expression values, where rows are genes, and columns are cells.  
- `cell_metadata`, a data frame, where rows are cells, and columns are cell attributes (such as celltype, cluster condition, day captured, etc).  
- `gene_metadata`, an data frame, where rows are features (e.g. genes), and columns as gene attributes, such as biotype, gc count, etc.  

**Required dimensions for input files**  
The expression value matrix **must**:  

- have the same number of columns as the `cell_metadata` has rows.  
- have the same number of rows as the `gene_metadata` has rows.  

Additionally:  

- row names of the `cell_metadata` object should match the column names of the expression matrix.  
- row names of the `gene_metadata` object should match row names of the expression matrix.  
- one of the columns of the `gene_metadata` should be names 'gene_short_name', which represents the gene symbol or simple name (generally used for plotting) for each genes.  


#### Generate a cell_data_set  
You can create a new `cell_data_set` (CDS) object as follows:  
```{r}

```
























---
title: "monocle2"
author: "yincy"
date: "3/17/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Abstract  
Single cell gene expression studies enables one to profile transcriptional regulation in complex biological processes and highly hetergeneous cell populations. These studies facilitate the discovery of genes that identify certain subtypes of cells, or that mark intermediate states during a biological process as well as bifurcate between two alternative cellular fates. In many single cell studies, individual cells are executing through a gene expression program in an unsynchronized manner. In effect, each cell is a snapshot of the transcriptional program under study. The package Monocle provides tools for analyzing single-cell expression experiments. Monocle introduced the strategy of ordering single cells in pseudotime, placing them along a trajectory corresponding to a biological process such as cell differentiation by taking advantage of individual cell's asynchronous progression of those processes. Monocle orders cells by learning an explicit principal graph from the single cell genomics data with advanced machine learning techniques (Reversed Graph Embedding), which robustly and accurately resolves complicated biological processes. Monocle also performs clustering (i.e. using t-SNE and density peaks clustering). Monocle then performs differential gene expression testing, allowing one to identify genes that are differentially expressed between different state, along a biological process as well as alternative cell fates. Monocle is designed for single cell RNA-Seq studies, but can be used with other assays.  

# Introduction  
The monocle package provides a toolkit for analyzing single cell gene expression experiments. This vignette provides an overview of a single cell RNA-Seq analysis workflow with Monocle. Monocle was originally developed to analyze dynamic biological processes such as cell differentiation, although it also supports other experimental settings.  

Monocle 2 includes new and improved algorithms for classifying and counting cells, performing differential expression analysis between subpopulations of cells, and reconstructing cellular trajectories. Monocle 2 has also been re-engineered to work well with very large single-cell RNA-Seq experiments containing tens of thousands of cells or more.  

Monocle can help you perform three main types of analysis:  

+ **Clustering, classifying, and counting cells**. Single-cell RNA-Seq experiments allow you to discover new (and possibly rare) subtypes of cells. Monocle helps you identify them.  

+ **Constructing single-cell trajectories**. In development, disease, and throughout life, cells transition from one state to another. Monocle helps you discover these transitions.  

+ **Differential expression analysis**. Characterizing new cell types and states begins with comparing them to other, better understood cells. Monocle includes a sophisticated but easy to use system for differential expression.  


# Workflow steps at a glance  
Below, you can see snippets of code that highlight the main steps of Monocle.   

## Store Data in a CellDataSet  
The first step in working with Monocle is to load your data into Monocle's main class `CellDataSet`  
```
pd <- new(Class = "AnnotatedDataFrame", data = sample_sheet)
fd <- new(Class = "AnnotatedDataFrame", data = gene_annotation)
cds <- newCellDataSet(cellData = expr_matrix, phenoData = pd, featureData = fd)
```

## Classify cells with known marker genes  
Next, leverage your knownlege of key marker genes to quickly and easily classify your cells by type  
```
cth <- newCellTypeHierarchy()
MYF5_id <- row.names(subset(fData(cds), gene_short_name == "MYF5"))
ANPEP_id <- row.names(subset(fData(cds), gene_short_name == "ANPEP"))

cth <- addCellType(cth = cth, 
                   cell_type_name = "Myoblast", 
                   classify_func = function(x){x[MYF5_id, ] > 1})

cth <- addCellType(cth = cth, 
                   cell_type_name = "Fibroblast", 
                   classify_func = function(x){x[MYF5_id, ] < 1 & x[ANPEP_id, ] > 1})

cds <- classifyCells(cds = cds, cth = cth,frequency_thresh = 0.1)
```

## Cluster cells  
cluster you cell to find new types  
```
csd <- clusterCells(cds = cds)
```

## OIrder cells in pseudotime along a trajectory  
Now, put your cells in order by how much progress they've made through whatever process you're studying, such as differentiation, reprogramming. or an immune response.  
```
disp_table <- dispersionTable(cds = cds)
ordering_genes <- subset(x = disp_table, mean_expression >= 0.1)
cds <- setOrderingFilter(cds = cds, ordering_genes = ordering_genes)
cds <- reduceDimension(cds = cds)
cds <- orderCells(cds = cds)
```

## Perform differential expression analysis  
Compare groups of cells in myriad ways to find differentially expressed genes, controlling for batch effects and treatments as you like  
```
diff_test_res <- differentialGeneTest(cds = cds, fullModelFormulaStr = "~Media")
sig_genes <- subset(diff_test_res, qval < 0.1)
```


# Getting Started with Monocle  
Monocle takes a matrix of gene expression values as calculated by Cufflinks or another gene expression estimation program. Monocle can work with relative expression values (e.g. FPKM or TPM units) or absolute transcript counts (e.g. from UMI experiments). Monocle also works "out-of-the-box" with the transcript count matrices produced by `CellRanger`, the software pipeline for analyzing experiments from the 10X Genomics Chromium instrument. Monocle also works well with data from other RNA-Seq workflows such as `sci-RNA-Seq` and instruments like the Biorad ddSEQ. Although Monocle can be used with raw read counts, these are not directly proportional to expression values unless you normalize them by length, so some Monocle functions could produce nonsense results. If you don't have UMI counts, We recommend you load up FPKM or TPM values instead of raw read counts.  


## The CellDataSet class  
Monocle holds single cell expression data in objects of the CellDataSet class. The class is derived from the Bioconductor ExpressionSet class, which provides a common interface familiar to those who have analyzed microarray experiments with Bioconductor. The class requires three input files:  

- `exprs`, a numeric matrix of expression values, where rows are cells, and columns are cells.  
- `phenoData`, an `AnnotatedDataFrame` object, where rows are cells, and columns are cell attributes (such as cell type, culture condition, day captured, etc.)  
- `featureData`, an `AnnotatedDataFrame` object, where rows are features (e.g. genes), and columns are gene attributes, such as biotypes, gc counts, etc.  

**Required dimensions for input files**  
The expression value matrix must:  

+ have the same number of columns as the `phenoData` has rows.  
+ have the same number of rows as the `featureData` data frame has rows.  


Additionally:  

+ row names of the `phenoData` object should match the column names of the expression matrix.  
+ row names of the `featureData` object should match row names of the expression matrix.    
+ one of the columns of the `featureData` should be named `gene_short_name`.  


You can create a new `CellDataSet` object as follows:  
```
HSMM_expr_matrix <- read.table(file = "fpkm_matrix.txt")
HSMM_sample_sheet <- read.delim(file = "cell_sample_sheet.txt")
HSMM_gene_annotation <- read.delim(file = "gene_annotations.txt")

pd <- new(Class = "AnnotatedDataFrame", data = HSMM_sample_sheet)
fd <- new(Class = "AnnotatedDataFrame", data = HSMM_gene_annotation)
HSMM <- newCellDataSet(cellData = as.matrix(HSMM_expr_matrix), 
                       phenoData = pd, 
                       featureData = fd)
```

This will create a `CellDataSet` object with expression values measured in FPKM. By default, MOnocle assumes that you expression data is in units of transcript counts and uses a negative binomial model to test for differential expression in downstream steps. However, if you're using relative expression values such as TPM or FPKM data, see below for how to tell Monocle to model it in downstream steps.  

**Don't normalize data yourself**  
if you do have UMI data, you should not normalize it yourself to creating your `CellDataSet`. You should also not try to convert the UMI counts to relative abundances (by converting it to FPKM/TPM data.) You should not use `relative2abs()` as discused below in the section on `Converting TPM to mRNA Counts.` Monocle will do all needed normalization steps internally. Normalizing it yourself eisks breaking some of Monocle's key steps.  

## Importing and exporting data with other packages  
Monocle is able to convert Seurat objects from the package "Seurat" and SCESets from the package "scater" into CellDataSet objects that Monocle can use. It's also worth noting that the function will also work with SCESets from "Scran". To convert from either a Seurat object or a SCESet to a CellDataSet, execute the function importCDS() as shown:  
```
# where 'data_to_be_imported' can either be Seurat object or an SCESet.  
importCDS(otherCDS = 'data_to_to_imported')

# we can set the parameter 'import_all' to TRUE if we'd like to import all the slots from our Seurat object or SCESet.  

importCDS(otherCDS = 'data_to_be_imported', import_all = TRUE)
```

Monocle can also export data from CEllDataSet to the 'Seurat' and 'scater' package through the function `exportCDS()`  
```
lung <- load_lung()

# to convert to Seurat object
lung_seurat <- exportCDS(monocle_cds = lung, export_to = "Seurat")

# to convert to SCESet  
lung_SCESet <- exportCDS(monocle_cds = lung, export_all = "Scater")
```

## Choosing a distribution for your data  
Monocle works well with both relative expression data and count-based measures (e.g. UMIs). In general, it works best with transcript count data, especially UMI data. Whatever your data type, it is critical that specify the appropriate distribution for it. FPKM/TPM values are generally log-normally distributed, while UMIs or read counts are better modeled with the negative binomial. To work with count data, specify the negative binomial distribution as the expressionFamily argument to newCellDataSet:  
```
HSMM <- newCellDataSet(cellData = count_matrix, 
                       phenoData = pd, 
                       featureData = fd, 
                       expressionFamily = negbinomial.size())
```

```{r}
knitr::include_graphics(path = "/home/yincy/git/Bioconductor/workflow/Single-Cell/monocle/figures/monocle2-family-functions.png")
```


## Working with large data sets  
Some single-cell RNA-Seq experiments report measurements from tens of thousands of cells or more. As instrumentation improves and costs drop, experiments will become ever larger and more complex, with many conditions, controls, and replicates. A matrix of expression data with 50,000 cells and a measurement for each of the 25,000+ genes in the human genome can take up a lot of memory. However, because current protocols typically don't capture all or even most of the mRNA molecules in each cell, many of the entries of expression matrices are zero. Using sparse matrices can help you work with huge datasets on a typical computer. We generally recommend the use of sparseMatrices for most users, as it speeds up many computations even for more modestly sized datasets.  

To work with your data in a sparse format, simply provide it to Monocle as spare matrix from the `Matrix` package  
```
HSMM <- newCellDataSet(cellData = as(umi_matrix, "sparseMatrix"), 
                       phenoData = pd, featureData = fd, 
                       lowerDetectionLimit = 0.5, 
                       expressionFamily = negbinomial.size())
```

## Converting TPM/FPKM values into mRNA counts  







































---
title: "SingleR"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Preface  
Imagine a world without a reference genome. Whenever we receive new RNA-seq data, we’d need to run it through an assembler to identify the expressed sequences. We would then need to inspect each sequence to determine its likely function, e.g., based on sequence motifs. This process is analogous to current practice in single-cell data analysis; simply replace reads with cells, assemblies with clusters, and genes with cell types. A typical practitioner will hope that their clusters are reasonable proxies for the biological states of interest and that their manual annotation of the clusters is accurate. Such an “artisanal” process is difficult to reproduce and scale to larger datasets involving more diverse cell types.  

The solution is to perform automated cell type annotation, a.k.a. cell type classification (or occasionally, “label transfer”). These methods compare cells in a new dataset against curated reference profiles of known cell types, assigning each new cell to the reference type that its expression profile is most similar to. This allows users to skip the mundane annotation of their data and jump directly to the interesting questions - does my cell type change in abundance or expression across treatments? Is there interesting substructure within an existing population? In this respect, automated annotation methods are the single-cell field’s equivalent to genome aligners, and we anticipate that the former will also become standard procedure for single-cell data analysis.  

# Chapter 1 Introduction  
## Motivation  
The Bioconductor package SingleR implements an automatic annotation method for single-cell RNA sequencing (scRNA-seq) data (Aran et al. 2019). Given a reference dataset of samples (single-cell or bulk) with known labels, it assigns those labels to new cells from a test dataset based on similarities in their expression profiles. This provides a convenient way of transferring biological knowledge across datasets, allowing users to leverage the domain expertise implicit in the creation of each reference. The most common application of SingleR involves predicting cell type (or “state”, or “kind”) in a new dataset, a process that is facilitated by the availability of curated references and compatibility with user-supplied datasets. In this manner, the burden of manually interpreting clusters and defining marker genes only has to be done once, for the reference dataset, and this knowledge can be propagated to new datasets in an automated manner.  

## Method description  
SingleR can be considered a robust variant of nearest-neighbors classification, with some tweaks to improve resolution for closely related labels. For each test cell:  

1. We compute the Spearman correlation between its expression profile and that of each reference sample. The use of Spearman's correlation provides a measure of robustness to batch effects across datasets. The calculation only uses the union of marker genes identified by pairwise between labels.  

2. We define the per-label score as a fixed quantile (by default, 0.8) of the correlations across all samples with that label. This accounts for differences in the number of reference samples for each label, which interferes with simpler flavors of nearest neighbor classification; it also avoids penalizing classifications to heterogeneous labels by only requiring a good match to a minority of samples.  

3. We repeat the score calculation for all labels in the reference dataset. The label with the highest score is used as SingleR’s prediction for this cell.  

4. We optionally perform a fine-tuning step to improve resolution between closely related labels. The reference dataset is subsetted to only include labels with scores close to the maximum; scores are recomputed using only marker genes for the subset of labels, thus focusing on the most relevant features; and this process is iterated until only one label remains.  

## Quick start  
We will demonstrate the use of `SingleR()` on a well-known 10X Genomics dataset (Zheng et al. 2017) with the Human Primary Cell Atlas dataset (Mabbott et al. 2013) as the reference.  

```{r}
# loading test data
library(TENxPBMCData)
new.data <- TENxPBMCData(dataset = "pbmc4k")

# loading reference data with ensembl annotations
library(celldex)
ref.data <- HumanPrimaryCellAtlasData(ensembl = TRUE)

# Performing predictions
library(SingleR)
predictions <- SingleR(test = new.data, 
                       assay.type.test = 1, 
                       ref = ref.data, 
                       labels = ref.data$label.main)

table(predictions$labels)
```

# Chapter 2 Using the classic mode
## Overview  
SingleR detects markers in a pairwise manner between labels in the reference dataset. Specifically, for each label of interest, it performs pairwise comparisons to every other label in the reference and identifies the genes that are upregulated in the label of interest for each comparison. The initial score calculation is then performed on the union of marker genes across all comparisons for all label. This approach ensures that the selected subset of features will contain genes that distinguish each label from any other label. (In contrast, other approaches that treat the “other” labels as a single group do not offer this guarantee; see here for a discussion.) It also allows the fine-tuning step to aggressively improve resolution by only using marker genes from comparisons where both labels have scores close to the maximum.  

The original (“classic”) marker detection algorithm used in Aran et al. (2019) identified marker genes based on their log-fold changes in each pairwise comparison. Specifically, it used the genes with the largest positive differences in the per-label median log-expression values between labels. The number of genes taken from each pairwise comparison was defined as  
$500\frac{2}{3}^{log_{2}(n)}$, where `n` is the number of unique labels in the reference; this scheme aimed to reduce the number of genes (and thus the computational time) as the number of labels and pairwise comparisons increased. Classic mode is primarily intended for reference datasets that have little or no replication, a description that covers many of the bulk-derived references and precludes more complicated marker detection procedures (Chapter 3).

## Annotating the test dataset  
For demonstration purposes, we will use the Grun et al. (2016) haematopoietic stem cell (HSC) dataset from the `scRNAseq` package. The `GrunHSCData()` function conveniently returns a `SingleCellExperiment` object containing the count matrix for this dataset.  

```{r}
library(scRNAseq)

sce.grun <- GrunHSCData(ensembl = TRUE)
sce.grun
```

Our aim is to annotate each cell with the ImmGen reference dataset (Heng et al. 2008) from the `celldex` package. (Some further comments on the choice of reference are provided below in Section 2.5.) Calling the `ImmGenData()` function returns a `SummarizedExperiment` object containing a matrix of log-expression values with sample-level labels. We also set `ensembl=TRUE` to match the reference’s gene annotation with that in the `sce` object - the default behavior is to use the gene symbol.  

```{r}
library(celldex)

immgen <- ImmGenData(ensembl = TRUE)
immgen
```

Each `celldex` dataset actually has three sets of labels that primarily differ in their resolution. For the purposes of this demonstration, we will use the “fine” labels in the `label.fine` metadata field, which represents the highest resolution of annotation available for this dataset.  

```{r}
head(immgen$label.fine)
```

We perform annotation by calling `SingleR()` on our test (Grun) dataset and the reference (ImmGen) dataset, leaving the default of `de.method="classic"` to use the original marker detection scheme. This applies the algorithm described in Section 1.2, returning a `DataFrame` where each row contains prediction results for a single cell in the sce object. Labels are provided before fine-tuning (`first.labels`), after fine-tuning (`labels`) and after pruning (`pruned.labels`); some of the other fields are discussed in more detail in Chapter 4.  

```{r}
library(SingleR)

# see 'choice of assay data' for 'assay.type.test=' explanation

pred <- SingleR(test = sce.grun, 
                ref = immgen, 
                labels = immgen$label.fine, 
                assay.type.test = 1)

colnames(pred)
```

# Interaction with quality control  
Upon examining the distribution of assigned labels, we see that many of them are related to stem cells. However, there are quite a large number of more differentiated labels mixed in, which is not what we expect from a sorted population of HSCs.  

```{r}
pred$labels %>% table %>% sort(decresing = T) %>% head
```

This is probably because - despite what its name might suggest - the dataset obtained by GrunHSCData() actually contains more than HSCs. If we restrict our analysis to the sorted HSCs (obviously) and remove one low-quality batch (see the analysis here for the rationale) we can see that the distribution of cell type labels is more similar to what we might expect. Low-quality cells lack information for accurate label assignment and need to be removed to enable interpretation of the results.  

```{r}
actual.hsc <- pred$labels[sce.grun$protocol == 'sorted hematopoietic stem cells' & sce.grun$sample != "JC4"]
actual.hsc %>% table %>% sort(decreasing = T) %>% head
```

Filtering the annotation results in the above manner is valid because `SingleR()` operates independently on each test cell. The annotation is orthogonal to any decisions about the relative quality of the cells in the test dataset; the same results will be obtained regardless of whether `SingleR` is run before or after quality control. This is logistically convenient as it means that the annotation does not have to be repeated if the quality control scheme (or any other downstream step, like clustering) changes throughout the lifetime of the analysis.  

## Choices of assay data
For the reference dataset, the assay matrix must contain log-transformed normalized expression values. This is because the default marker detection scheme computes log-fold changes by subtracting the medians, which makes little sense unless the input expression values are already log-transformed. For alternative schemes, this requirement may be relaxed (e.g., Wilcoxon rank sum tests do not require transformation); similarly, if pre-defined markers are supplied, no transformation or normalization is necessary.  

For the test data, the assay data need not be log-transformed or even (scale) normalized. This is because `SingleR()` computes Spearman correlations within each cell, which is unaffected by monotonic transformations like cell-specific scaling or log-transformation. It is perfectly satisfactory to provide the raw counts for the test dataset to `SingleR()`, which is the reason for setting `assay.type.test=1` in our previous `SingleR()` call for the Grun dataset.  

The exception to this rule occurs when comparing data from full-length technologies to the `celldex` references. These references are intended to be comparable to data from unique molecular identifier (UMI) protocols where the expression values are less sensitive to differences in gene length. Thus, when annotating Smart-seq2 test datasets against the `celldex` references, better performance can often be achieved by processing the test counts to transcripts-per-million values.  

We demonstrate below using another HSC dataset that was generated using the Smart-seq2 protocol (Nestorowa et al. 2016). Again, we see that most of the predicted labels are related to stem cells, which is comforting.  
























---
title: "IRanges"
author: "yincy"
date: "11/5/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r load package, message=FALSE}
library(IRanges)
library(magrittr)
```

`IRanges` are collections of integer intervals. `GRanges` are like `IRanges`, but with an associated chromosome and strand, taking care of some book keeping.  


## Basic IRanges  
```{r}
?IRanges
irl <- IRanges(start = c(1, 3, 5), end = c(3, 5, 7))
```

```{r}
ir2 <- IRanges(start = c(1, 3, 5), width = 3)
```

```{r}
all.equal(irl, ir2)
```

An `IRanges` consist of separate intervals; each interval is called a range. So `irl` above contains 3 ranges.   

**Assessor methods: `start()`, `end()`, `width()` and also replacement methods**.  

```{r}
start(irl)
```

```{r}
width(irl)
```

```{r}
width(irl) <- 1
irl
```

```{r give they are names}
names(irl) <- paste("A", 1:3, sep = "") # row names 
irl
```

```{r IRange object only have one dimension}
dim(irl); length(irl)
```

```{r subsetting like vector}
irl[1]
```

```{r}
irl["A1"]
```

```{r concatenate two IRanges with c() function}
c(irl, ir2)
```


## Normal IRanges  
A normal IRanges is a minimal representation of the IRanges viewed as a set. Each integer only occur in a single range and there are as few ranges as possible. In addition, it is ordered.  

Many functions produce a normal `IRanges`. Created by `reduce()`.  
```{r}
ir <- IRanges(start = c(1, 3, 7, 9), width = c(4, 2, 2, 2))
```

```{r}
reduce(ir)
```

![](./graph/reduce.PNG)


## Disjoin   
From some perspective, `disjoin()` is the opposite of `reduce()`.  
```{r}
ir
disjoin(ir)
```

![](./graph/disjoin.PNG)


## Manipulating IRanges, intra-range  
"Intra-range" manipulations are manipulations where each original range gets mapped to a new range.  

Examples of these are: `shift()`, `narrow()`, `flank()`, `resize()`, `restrict()`.  

`resize()` can be extremely useful. it has a *fix* argument controlling where the resizing occurs from. Use **fix = "center"** to resize around the center of the ranges.  

```{r}
resize(ir, width = 1, fix = 'start')
```

```{r}
resize(ir, width = 1, fix = "center")
```

More help can be found at `?"intra-range-methods"`  


## Manipulating IRanges as sets  
Manipulating `IRanges` as sets means that we view each `IRanges` as a set of integers; individual integers is either contained in one or more ranges or they are not. This is equivalent to calling `reduce()` on the `IRanges` first.  

Once this is done, we can use standard: `union()`, `intersect()`, `setdiff()`, `gaps()` between two `IRanges` (which all returns normalized `IRanges`).  

```{r union}
ir1 <- IRanges(start = c(1, 3, 5), width = 1)
ir2 <- IRanges(start = c(4, 5, 6), width = 1)
ir1;ir2;union(ir1, ir2)
```

```{r intersect}
intersect(ir1, ir2)
```

Because they return normalized `IRanges`, an alternative to `union()` is  
```{r}
reduce(c(ir1, ir2))
```

There are also an element-wise (pair-wise) version of these: `punion()`, `pintersect()`, `pgap()`; this is similar to say `pmax` from base R.  


## Finding Overlaps  
Finding (pair-wise) overlaps between two `IRanges` is done by `findOverlaps()`. This function is very important and amazingly fast!  
```{r}
ir1 <- IRanges(start = c(1, 4, 8), end = c(3, 7, 10))
ir2 <- IRanges(start = c(3, 4), width = 3)

ov <- findOverlaps(query = ir1, subject = ir2)
ov
```

It returns a `Hits` object which describes the relationship between the two `IRanges`. This object is basically a two-column matrix of indicies into the two `IRanges`.  

The two columns of the hits object can be accessed by `queryHits()` and `subjectHits`(often used with `unique()`).  

```{r}
queryHits(ov) %>% unique()
```


```{r}
intersect(x = ir1[queryHits(ov)], y = ir2[subjectHits(ov)]) %>% unique()
```


```{r}
args(findOverlaps)
```

you can ask to only get an overlap if two ranges overlap by a certain number of bases.  


## countOverlaps  
`countOverlaps()` which just returns the number of overlaps.  
```{r}
countOverlaps(query = ir1, subject = ir2) # query overlaped with subject
```



## Finding nearest IRanges  
Sometimes you have two sets of `IRanges` and you need to known which ones are closest to each other.  

Functions for this include `nearest()`, `preced()`, `follow()`.  

```{r}
ir1
```

```{r}
ir2
```

```{r}
nearest(x = ir1, subject = ir2)
```

## Summary 
- IRange object just like a vector  

- IRange object elements can be accessed and replaced like vector  

- IRange object elements can be manipulated like set  































---
title: "R-Programming-for-Bioinformatics"
author: "yincy"
date: "1/10/2020"
output: html_document:
    toc: true
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Chapter 2  R Language Fundamentals  
**Many Operations in R are vectorized, and understanding and using vectorization is an essential component of becoming a proficient programmer**.  

**Attributes**:  

- Attributes can be attached to any R object except `NULL` and they are used quite extensively.  
- Attributes are stored, by name, in a list.  
- All attributes can be retrived using `attributes`, or any particular attribute can be accessed or modified using the `attr` function.  
- Attributes can be used by programmers to attach any sort of information they want to any R object. R uses attributes for amny things; the S3 class system is based largely on attributes, dimensions of arrays, and names on vectors, to name but a few.   

```{r}
x <- 1:10
attr(x, "foo") <- 11
x
```

```{r}
mean
methods(mean)
```


### Some special values  
**NULL**: The value **NULL** is the null object. It has length zero and disappears when concatentated with any other object. It is the default value for the elements of a list.  
**NA**: misssing value. It is worth emphasizing that there is a distinct missing value (NA) for each basic type and these can be accessed through constants such as **NA_integer_**.   

```{r}
typeof(NA)
as.character(NA)
as.integer(NA)
typeof(as.integer(NA))
typeof(as.character(NA))
```

**Inf** and **-Inf**: infinity, `is.finite()`, `is.infinite`  

```{r}
y <- 1/0
y
-y
```

**NaN**: not a number, `is.nan`  

```{r}
y - y
```

### Types of objects  

Vector:  

- logical  
- integer  
- real  
- complex  
- string  
- raw  

```{r}
typeof(y)
typeof(is.na)
typeof(mean)

mode(NA)
storage.mode(letters)
```

```{r}
is.integer(y)
is.double(y)
is.character(y)
is.numeric(y)
```

Types of functions:  

- builtins  
- specials  
- closures   

Users can only create closures (unless they want to modify the internals of R), and these are the easiest functions to understand since they are written in R.  

The main difference between the two types of internal functions is whether or not they evaluate their arguments; specials do not.  


S regards an array as consisting of a vector containing the array’s elements, together with a dimension (or `dim`) attribute. A vector can be given dimensions by using the f unctions `matrix` (two-dimensional data) or `array` (any number of dimensions), or by directly attaching them with the `dim` function.  

Array extents can be named by using the dimnames function or the dimnames argument to matrix or array. Extent names are given as a list, with each list element being a vector of names for the corresponding extent.  

```{r}
x <- 1:9
dim(x) <- c(3, 3)
x
dimnames(x) <- list(r = c("A", "B", "C"), c = c("a", "b", "c"))
```


### Numerical computing  
It is important to remember that computers cannot represent all numbers and that machine computation is not identical to computation with real numbers.  

The only numbers that can be represented exactly in R’s numeric type are (some) integers and fractions whose denominator is a power of 2. Other numbers have to be rounded to (typically) 53 binary digits accuracy.  

As a result, two floating point numbers will not reliably be equal unless they have been computed by the same algorithm, and not always even then.  

The numerical characteristics of the computer that R is running on can be obtained from the variable named `.Machine`.  

The function `all.equal` compares two objects using a numeric tolerance of
.Machine$double.eps^0.5.  


### Factors  
A factor is useful when a potentially large collection of data contains relatively few, discrete levels.  

Factors are not vectors and, in particular, `is.vector` returns **FALSE** for factor.  

A factor is represented as an object of class factor, which is an integer vector of codes and an attribute with name **levels**.  

Factors are instances of S3 classes. Ordinary factors have clas factor and ordered factors have a class vector of length two with ordered as the additional elements.  

There are two tasks that are often performed on factors:  

- One is to drop unused levels; this can be achieved by a call to **factor** since **factor(y)** will drop any unused levels from y if y is a factor.  

- The second tasks is to coarsen the levels of a factor, that is group two or more of them together into a single new level.  


```{r}
set.seed(123)
x <- sample(letters[1:5], 10, replace = T)
y <- factor(x)
y
attributes(y)
```


```{r}
y <- sample(letters[1:5], 20, replace = T)
v <- as.factor(y)
xx <- list(I = c("a", "e"), II = c("b", "c", "d"))
levels(v) <- xx
v
```


In R the value returned by a function is either the value that is explicitly returned by a call to the function `return` or it is simply the value of the last expression.  

```{r}
seq1 <- function(x) return(x * x)
seq2 <- function(x)x * x

seq1(1:10)
seq2(1:10)
```


```{r}
pcc <- function(str){
    paste("^", str, sep = "")
}
pcc("abcd")
```


```{r}
scol <- function(mat){
    for(i in 1:dim(mat)[1]){
        med <- median(mat[i, ])
        mad <- mad(mat[i, ])
        for(j in 1:dim(mat)[2]){
            mat[i, j] <- (mat[i, j] - med)/mad
        }
    }
    return(mat)
}


scol(matrix(1:9, 3))


scol <- function(mat, center, spread){
    med <- center
    mad <- spread
    for(i in 1:dim(mat)[1]){
        for(j in 1:dim(mat)[2]){
            mat[i, j] <- (mat[i, j] - med)/mad
        }
    }
    return(mat)
}

scol(matrix(1:9, 3), 3, 3)
```


scale function:  

- `scale`  
- `sweep`: more general than `scale`  



Functional programming:  

- `Reduce`  
- `Filter`  
- `Map`  
- `Negate`  


## Flow Control  
There are three basic paradigms for iteration:  

- `for`  
- `repeat`  
- `while`  

for(var in seq) expr  
while(cond) expr  
repeat expr  

The use of `break` halts the execution of the inner-most loop and passes control to the next statement.  

The use of `next` halts the execution of the current expr and begins the next evaluation.  



# Chapter 3 Object-Oriented Programming in R  
In an OOP system, real physical things (like airline passengers or the data from a microarray experiment) are generally repre- sented by classes, and methods (functions) are written to handle the different manipulations that need to be performed on the objects.  

In a class-centric system, classes define objects and are repositories for the methods that act on those objects.  

In contrast, languages such as Dylan, Common Lisp, and R separate the class specification from the specification of generic functions, and could be described as being function-centric systems.  

Four general elements that an object-oriented programming language should support:  

- **objects**: encapsulate state information and control behavior.  

- **classes**: describe general properties for groups of objects.  

- **inheritance**: new classes can be defined in terms of existing classes.  

- **polymorphism**: a (generic) function has different behaviors, although similar outputs, depending on the class of one or more its arguments.  


Virtually every OOP language implements these in different ways.  

In S3, there is no formal specification for classes and hence there is, at best, weak control of objects and inheritance. The emphasis of the S3 system was on generic functions and polymorphism.  

In S4, formal class definitions were included in the language and based on these, more controlled software tools and paradigms for the creation of objects and the handling of inheritance were introduced.  


## The basic of OOP  
 - A class specification details all the properties that are needed to describe an object.  
 
- An object is an instance of exactly one class and it is the class definition and representation that determine the properties of the object.  

- Instances of a class differ only in their state.  

- New classes can be defined in terms of existing classes through an operation called inheritance.  

- Inheritance allows new classes to extend, often by adding new slots or by combining two or more existing classes into a single composite entity.  

- No class can be its own subclass. A class is a subclass of each of its superclasses.  
- If the language only allows a class to extend, at most, one class, then we
say that language has single inheritance.  

- In the S3 system, the class of an instance is determined by the values in the class attribute, which is a vector, and hence is also linear.  

- If the language allows a class to directly extend several classes, then we say that the language supports multiple inheritance and computing the class linearization is more difficult. S4 support multiple dispatch.  

- A mehtod is a type of function that is invoked depending on the class of one or more of its arguments and this process is called dispatch.  

- In some systems, such as S3, methods can be invoked directly, it is more common for them to be invoked via a generic function. When a generic funciton is invoked, the set of methods that might apply must be sorted into a linear order, with the most specific method first and the least specific method last. This is often called method linearization and computing it depends on being able to linearize the class hierarchy.  

- If the language supports dispatching on a single argument, then we say it has single dispatch. Both Java anf the S3 system use single dispatch.  

- When the language supports dispatch on several arguments, we say that the language supports multiple dispatch and the set of specific classes of the arguments for each formal parameter of generic function is called the signature. S4 support multiple dispatch.  

- With multiple dispatch, the additional complication of precedence of the arguments arises. In particular, when method selection depends on inheritance, there may be more than one superclass for which a method has been defined. In this case, a concept of the distance between the class and its superclasses is used to guide selection.  

### Inheritance  
One of the advantages of a class system is the concept f inheritance.  

The inheritance relationships imply a form of polymorphism. Any instance of the sbclass can be used in place of an instance of the superclass.  

The relationship between a subclass and its superclass should be an *is a* relationship.  

```{r}
setClass(Class = "Passenger", representation(name = "character", origin = "character", destination = "character"))

setClass(Class = "FreqFlyer", representation(ffnumber = "numeric"), contains = "Passenger")

getClass('FreqFlyer')
```


```{r}
setClass(Class = "passenger", representation = list(
    first_name = "character", 
    last_name = "character",
    middle_name = "character",
    origin = "character",
    destination = "character"
))

getClass('passenger')
```



### Dispatch  
A method is a specialized function that can be applied to instances of one or more classes. The process of determining the appropriate method to invoke is called dispatch.  

When a generic function is called, it must examine the supplied arguments and determine the applicable methods. All applicable methods are ordered, while for S3 the hierarchy is intrinsically linear and hence has an obvious order.  

In both systems, the applicable methods are arranged from most specific to least specific and the most specific methods is invoked.  

During evaluation, control may be passed to less specific methods by calling `NextMethod` in S3 and via `callNextMethod` for S4.  

In the S3 system, the generic function typically only examines the first argument and dispatches depending on its class.  


### Abstract data types  
In some discussions there is confusion between the use of abstract data types(ADT) and OOP. It is usefull to realize that the ADT paradigm can be adopted in any language, regardless of whether or not it supports OOP.  

All users of the data type must restrict their operations to those defined by the interface.  

```{r}
setClass(Class = "Rectangle", representation = list(
    h = "numeric",
    w = "numeric",
    area = "numeric"
))


myr <- new(Class = "Rectangle", h = 10, w = 20, area = 200)

setGeneric(name = "area", def = function(shape) standardGeneric(f = "area"))

setMethod(f = "area", 
          signature = signature(shape = "Rectangle"),
          definition = function(shape)shape@area)

myr@area

area(myr)
```


### Self-describing data  
One of the major uses of OOP within the Bioconductor Project is in the construction of self-describing data classes.  

If all information is stored in a single object it is easier to save it, to share it with others, or to use it as input to a function.  

The major benefits that we have found to programming with self-describing
data are that it is easy to return to a project after some months and re-do an analysis.  

We have also found that it is relatively easy to hand off a project from one analyst to another.  

But perhaps the greatest benefit has come from defining specialized subsetting methods, that is, methods for [ that help to construct an appropriate subset of the object, with all variables correctly aligned.  


## S3 OOP  
The S3 system is relatively easy to describe and to use. It is particularly well suited to interactive use but is not particularly robust.   

Generic functions and methods are quite widely used but there is little use of inheritance and classes are quite loosely defined. In some sense, all objects in R are instances of some class.  

Using `setOldClass` will register an S3 class as an S4 class.  

The `class` attribute is a vector of character values, each of which specifies a particular class. The most specific class comes first, followed by any less specific classes.  

```{r}
x <- 1:10
class(x)

dim(x) = c(2,5)
class(x)
attr(x, "class")
inherits(x, "integer")
```


```{r}
x <- list(name = "Josephine Biologist", 
          origin = "SEA",
          destination = "YXY")
class(x) <- "Passenger"

y <- list(name = "Josephine Physicist",
          origin = "SEA",
          destination = "YVA",
          ffnumber = 10)
class(y) <- "FreqFlyer"

inherits(y, "Passenger")
inherits(x, "FreqFlyer")
```

```{r}
is.object(x)
is.object(y)

class(x);class(y)
```


The function `is.object` tests  whether or not an R object has a `class` attribute.  


### S3 generic functions and methods  
In S3, the genric function is responsible for setting up the evaluation environment and for initiating dispatch.   

A generic function does this through a call to `UseMethod` that initiates the dispatch on a single argument, usually the first argument to the generic function.  

For most generic functions, a default method will be needed. The default method is invoked if no applicable methods are found, or if the least specific method makes a call to NextMethod.  

Methods are regular functions and are identified by their name, which is a concatenation of the name of the generic and the name of the class that they are intended to apply to, separated by a dot.  

```{r}
fun <- function(x, ...) UseMethod("fun")
fun.default = function(x, ...) print("In the default method")
fun(2)
```

```{r}
fun.Foo <- function(x){
    print("start of fun.Foo")
    NextMethod()
    print("end of fun.Foo")
}

fun.Bar <- function(x){
    print("start of fun.Bar")
    NextMethod()
    print("end of fun.Bar")
}
```

How method dispatch works  
```{r}
x <- 1
class(x) <- c("Foo", "Bar")

fun(x)
```
Notice that the call to `NextMethod` transfers control to the next most specific method.  


#### Finding methods  
The function `methods` reports on all available methods for a given generic function but is does this simply by looking at the names.  

find all methods for a given generic function  
```{r}
methods(generic.function = "mean")
```

find all method for a given class
```{r}
methods(class = "glm")
```


### Group generics  
The S3 object system also has the capability for defining methods for groups of functions simultaneously.  



## S4 OOP  
Multiple dispatch is supported in S4, but not in S3, and S4 methods are registered directly with the appropriate generic.  

These changes greatly increase the stability of the system and make it much more likely that code will perform as intended by its authors.  

This comes with some costs, however; code is slightly slower (since all aspects are slightly more complex) and it is more difficult to design and modify a system interactively.  


### Classes  
A class definition specifies the structure, inheritance and initialization of instances of that class.  

Classes are instances of the classRepresentation class, and are first-class ob- jects in the language.  

They can be created by users and existing classes can typically be extended or subclassed.  

Classes can be instantiable or virtual; instances can be created for instantiable classes but not for virtual classes.  


The following arguments can be specified (there are others as well) in the call to `setClass`:  

- `Class` a character string naming the class.  

- `representation` a named vector of types or classes. The names correspond to the slot names in the class and the types indicate what type of value can be stored in the slot.   

- `contains` a character vector of class names, indicating the classes extended or subclassed by the new class.  

- `prototype` an object (usually a list) providing the default data for the slots specified in the representation.  

- `validity` a function that checks the validity of instances of the class. It must return either **TRUE** or a character vector describing how the object is invalid.  

Once a class has been defined by a call to `setClass`, it is possible to create instances of the class through calls to `new`.  

```{r}
setClass(Class = "A",
         representation = list(
             s1 = 'numeric'
         ),
         prototype = prototype(s1 = 0))

myA <- new(Class = 'A')
myA

m2 <- new(Class = "A", s1 = 10)
m2
```


```{r}
setClass(Class = "B",
         contains = 'A',
         representation = list(s2 = "character"),
         prototype = prototype(s2 = "hi"))

myB <- new("B")
myB
```


`removeClass`  
```{r}
setClass(Class = "Ohno", 
         representation = list(y = "numeric"))

getClass("Ohno")
removeClass(Class = "Ohno")

tryCatch(expr = getClass(Class = "Ohno"), error = function(x)"Ohno is gone")
getClass(Class = "Ohno")
```


```{r}
getSlots('B')
slotNames("B")
```

```{r}
extends("B")
```


```{r}
extends("B", "A")
```

```{r}
extends("A", "B")
```


```{r}
getClass("matrix")
```

```{r}
extends("matrix")
```


```{r, message=F, warning=F}
library('RBioinf')
```

```{r}
superClassNames("B")
subClassNames("A")
```


One form is coercion where an instance of one class is coerced to the other class, and the second form is an assignment version, where a portion of the object supplied is coerced.  

```{r}
myb <- new(Class = "B")
as(myb, "A")
```


```{r}
mya <- new(Class = "A", s1 = 20)
as(myb, "A") <- mya
myb
```


#### Creation of new instances  
```{r}
setClass(Class = "Ex1",
         representation = list(s1 = "numeric"),
         prototype = prototype(s1 = rnorm(10)))
```

```{r}
b <- new(Class = "Ex1")

a <- new(Class = "Ex1")
b;a
```

















---
title: "R-Programming-for-Bioinformatics"
author: "yincy"
date: "1/10/2020"
output: html_document:
    toc: true
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Chapter 2  R Language Fundamentals  
**Many Operations in R are vectorized, and understanding and using vectorization is an essential component of becoming a proficient programmer**.  

**Attributes**:  

- Attributes can be attached to any R object except `NULL` and they are used quite extensively.  
- Attributes are stored, by name, in a list.  
- All attributes can be retrived using `attributes`, or any particular attribute can be accessed or modified using the `attr` function.  
- Attributes can be used by programmers to attach any sort of information they want to any R object. R uses attributes for amny things; the S3 class system is based largely on attributes, dimensions of arrays, and names on vectors, to name but a few.   

```{r}
x <- 1:10
attr(x, "foo") <- 11
x
```

```{r}
mean
methods(mean)
```


### Some special values  
**NULL**: The value **NULL** is the null object. It has length zero and disappears when concatentated with any other object. It is the default value for the elements of a list.  
**NA**: misssing value. It is worth emphasizing that there is a distinct missing value (NA) for each basic type and these can be accessed through constants such as **NA_integer_**.   

```{r}
typeof(NA)
as.character(NA)
as.integer(NA)
typeof(as.integer(NA))
typeof(as.character(NA))
```

**Inf** and **-Inf**: infinity, `is.finite()`, `is.infinite`  

```{r}
y <- 1/0
y
-y
```

**NaN**: not a number, `is.nan`  

```{r}
y - y
```

### Types of objects  

Vector:  

- logical  
- integer  
- real  
- complex  
- string  
- raw  

```{r}
typeof(y)
typeof(is.na)
typeof(mean)

mode(NA)
storage.mode(letters)
```

```{r}
is.integer(y)
is.double(y)
is.character(y)
is.numeric(y)
```

Types of functions:  

- builtins  
- specials  
- closures   

Users can only create closures (unless they want to modify the internals of R), and these are the easiest functions to understand since they are written in R.  

The main difference between the two types of internal functions is whether or not they evaluate their arguments; specials do not.  


S regards an array as consisting of a vector containing the array’s elements, together with a dimension (or `dim`) attribute. A vector can be given dimensions by using the f unctions `matrix` (two-dimensional data) or `array` (any number of dimensions), or by directly attaching them with the `dim` function.  

Array extents can be named by using the dimnames function or the dimnames argument to matrix or array. Extent names are given as a list, with each list element being a vector of names for the corresponding extent.  

```{r}
x <- 1:9
dim(x) <- c(3, 3)
x
dimnames(x) <- list(r = c("A", "B", "C"), c = c("a", "b", "c"))
```


### Numerical computing  
It is important to remember that computers cannot represent all numbers and that machine computation is not identical to computation with real numbers.  

The only numbers that can be represented exactly in R’s numeric type are (some) integers and fractions whose denominator is a power of 2. Other numbers have to be rounded to (typically) 53 binary digits accuracy.  

As a result, two floating point numbers will not reliably be equal unless they have been computed by the same algorithm, and not always even then.  

The numerical characteristics of the computer that R is running on can be obtained from the variable named `.Machine`.  

The function `all.equal` compares two objects using a numeric tolerance of
.Machine$double.eps^0.5.  


### Factors  
A factor is useful when a potentially large collection of data contains relatively few, discrete levels.  

Factors are not vectors and, in particular, `is.vector` returns **FALSE** for factor.  

A factor is represented as an object of class factor, which is an integer vector of codes and an attribute with name **levels**.  

Factors are instances of S3 classes. Ordinary factors have clas factor and ordered factors have a class vector of length two with ordered as the additional elements.  

There are two tasks that are often performed on factors:  

- One is to drop unused levels; this can be achieved by a call to **factor** since **factor(y)** will drop any unused levels from y if y is a factor.  

- The second tasks is to coarsen the levels of a factor, that is group two or more of them together into a single new level.  


```{r}
set.seed(123)
x <- sample(letters[1:5], 10, replace = T)
y <- factor(x)
y
attributes(y)
```


```{r}
y <- sample(letters[1:5], 20, replace = T)
v <- as.factor(y)
xx <- list(I = c("a", "e"), II = c("b", "c", "d"))
levels(v) <- xx
v
```


In R the value returned by a function is either the value that is explicitly returned by a call to the function `return` or it is simply the value of the last expression.  

```{r}
seq1 <- function(x) return(x * x)
seq2 <- function(x)x * x

seq1(1:10)
seq2(1:10)
```


```{r}
pcc <- function(str){
    paste("^", str, sep = "")
}
pcc("abcd")
```


```{r}
scol <- function(mat){
    for(i in 1:dim(mat)[1]){
        med <- median(mat[i, ])
        mad <- mad(mat[i, ])
        for(j in 1:dim(mat)[2]){
            mat[i, j] <- (mat[i, j] - med)/mad
        }
    }
    return(mat)
}


scol(matrix(1:9, 3))


scol <- function(mat, center, spread){
    med <- center
    mad <- spread
    for(i in 1:dim(mat)[1]){
        for(j in 1:dim(mat)[2]){
            mat[i, j] <- (mat[i, j] - med)/mad
        }
    }
    return(mat)
}

scol(matrix(1:9, 3), 3, 3)
```


scale function:  

- `scale`  
- `sweep`: more general than `scale`  



Functional programming:  

- `Reduce`  
- `Filter`  
- `Map`  
- `Negate`  


## Flow Control  
There are three basic paradigms for iteration:  

- `for`  
- `repeat`  
- `while`  

for(var in seq) expr  
while(cond) expr  
repeat expr  

The use of `break` halts the execution of the inner-most loop and passes control to the next statement.  

The use of `next` halts the execution of the current expr and begins the next evaluation.  










































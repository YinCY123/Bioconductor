---
title: "AnnotationHub"
author: "yincy"
date: "11/6/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load packages, message=FALSE}
library(GenomicRanges)
library(rtracklayer)
library(AnnotationHub)
library(magrittr)
```

## Overview  
We are going to use AnnotationHub and GenomicRanges to access ENCODE data on the H3K4me3 histone modification in a specific cell line. This histone modification is believed to mark active promoters, and we are going to attempt to verify this statement.  

- getting the ENCODE histone data using AnnotationHub  
- getting promoters using AnnotationHub  
- comparing the histone data and promoters using `findOverlaps` in GenomicRanges.  

## Getting the data  
```{r}
ah <- AnnotationHub()
```

The object is organized as a vector, with single-dimension indexing. You can get information about a single resource by indexing with a single `[`; using two brackets `[[` downloads the object.  
```{r}
ah[1]
```

The way you use `AnnotationHub` is by using various tools to narrow down your hub to a single or a small number of datasets. Then you download these datasets for your own usage.  
```{r}
unique(ah$dataprovider)
```

```{r}
unique(ah$rdataclass)
```

You can narrow down the hub by using one (or more) of the following strategies  
- Use `subset` (or `[`) to do a specific subsetting operation.  
- Use `query` to do a command-line search over the metadata of the hub.  
- Use `display` to get a Shiny interface in a browser, so you can browse the object.  

It is often useful to start with a very rough subsetting, for example to data from a specific species. The subset function is useful for doing a standard R subsetting (the function also works on data.frames).  

```{r}
ah <- subset(ah, species == "Homo sapiens")
```

We can use `query` to search the hub. The (possible) drawback to query is that it searches over different fields in the hub, so watch out with using s search term which is very non-specific. The query is a regular expression, which by default is case-insensitive. Here we locate all datasets on the H3K4me3 histone modification (in H. sapiens because we selected this species above).  
U
```{r}
query(ah, "H3K4me3")
```

```{r}
hist <- display(ah)
```


search for two keywords: **H3K4me3** and **Gm12878** which is the name of the cell line we are interested in.  
```{r}
phs <- query(ah, pattern = "H3K4me3")
phs <- query(ah, pattern = "Gm12878")
```
NOTE: query searching in multiple fields  

```{r}
phs
```

```{r}
phs$title %>% head()
```


```{r}
phs$dataprovider %>% unique()
```


This result is a great illustration of the mess of public data. It turns our that E116 is a Roadmap Epigenetics code for the Gm12878 cell line. The first 5 hits are from ENCODE, hosted at UCSC and the last 6 hits are from Roadmap Epigenomics hosted at the Broad Institute. The Roadmap data is different representation (and peaks) from the same underlying data. For the ENCODE data, two different centers did the same experiment in the same cell line (Broad, hit 1) and (Uw, hit 2-5), where Uw exposed data on two replicates (whatever that means). These two experiments seems to be analyzed using different algorithms. It is even possible that the Roadmap data is from the same raw data but just analyzed using different algorithms.  

```{r}
gr <- subset(phs, title == "wgEncodeUwHistoneGm12878H3k4me3StdPkRep1.narrowPeak.gz")[[1]]
```

```{r}
gr2 <- subset(phs, title == "E116-H3K4me3.narrowPeak.gz")[[1]]
```


This gives us two GRanges objects, let's look at the distribution of peak widths  
```{r}
summary(width(gr));summary(width(gr2))
```


```{r}
summary(width(gr));summary(width(gr2))
```


```{r}
phs <- query(ah, pattern = "RefSeq")
```

```{r}
refseq <- phs[phs$genome == "hg19" & phs$title == "RefSeq Genes"]
```

```{r}
refseq <- refseq[[1]]
```

```{r}
table(refseq$name) %>% table()
```

(the table(table()) construction may seems weird at first, but its a great way to get a quick tabular summary of occurrences with the same name). This shows that almost all genes have a single transcript, which reflects how conservative RefSeq is.  


```{r}
promoters <- promoters(refseq)
table(width(promoters))
```

```{r}
ov <- findOverlaps(query = promoters, subject = gr)
```

how many percent of the peaks are in a promoter  
```{r}
length(unique(queryHits(ov)))/length(gr)
```

how many percent of promoters have a peak in them  
```{r}
length(unique(subjectHits(ov)))/length(promoters)
```

My rule of thumb is that any cell type has at most 50% of genes expressed, which fits well with these numbers. We also see that there are many H3K4me3 peaks which do not lie in a genic promoter. This is actually expected.  

```{r}
sum(width(reduce(gr))) / 10^6
```

```{r}
sum(width(reduce(promoters)))/10^6
```

```{r}
sum(width(intersect(gr, promoters, ignore.strand = T)))/10^6
```


# from vignette  
## Accessing Genome-Scale Data  
### Non-model organism gene annotations  
Bioconductor offers pre-built org.* annotation packages for model organisms, with their use described in the OrgDb section of the Annotation work flow. Here we discover available OrgDb objects for less-model organisms  

```{r}
library(AnnotationHub)
```

```{r}
ah <- AnnotationHub()
```

```{r}
query(ah, "OrgDb")
```

```{r}
orgdb <- query(x = ah, pattern = c("OrgDb", "maintainer@bioconductor.org"))[[1]]
```

```{r}
keytypes(orgdb)
```

```{r}
columns(orgdb)
```


# From vignette  
## AnnotationHub objects  
```{r}
ah <- AnnotationHub()
```

Now at this point you have already done everything you need in order to start retrieving annotations. For most operations, using the AnnotationHub object should feel a lot like working with a familiar `list` or `data.frame`.  

```{r}
ah
```

```{r}
ah$dataprovider %>% unique()
```


```{r}
ah$species %>% unique() %>% head()
```

```{r}
ah$rdataclass %>% unique() %>% head()
```

The query method lets you search rows for specific strings, returning an AnnotationHub instance with just the rows matching the query.  

```{r}
dm <- query(x = ah, pattern = c("ChainFile", "UCSC", "Drosophila melanogaster"))
```


```{r}
mcols(dm)
```

By default the show method will only display the first 5 and last 5 rows. There are already thousands of records present in the hub.  


```{r}
ahs <- query(x = ah, pattern = c("inparanoid8", "ailuropoda"))
```

```{r}
d <- display(object = ah)
```


## Using AnnotationHub to retrieve data  
```{r}
dm
```

```{r}
dm["AH15146"]
```

downloading  
```{r}
dm[["AH15146"]]
```


## Configuring AnnotationHub objects  
When you create the `AnnotationHub` object, it will set up the object for you with some default settings. See `?AnnotationHub` for ways to customize the hub source, the local cache, and other instance-specific options, and `?getAnnotationHubOption` to get or set package-global options for use across sessions.  

```{r}
ah
```

By default the AnnotationHub object is set to the latest snapshotData and a snapshot version that matches the version of Bioconductor that you are using. You can also learn about these data with the appropriate methods.  
```{r}
snapshotDate(ah)
```

If you are interested in using an older version of a snapshot, you can list previous versions with the possibleDates() like this  
```{r}
pd <- possibleDates(ah)
```

```{r}
snapshotDate(ah) <- pd[1]
```


